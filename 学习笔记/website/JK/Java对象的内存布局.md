## Java对象的内存布局

#### 创建对象的方式

+ 反射机制
+ Object.clone 方法
+ 反序列化
+ Unsafe.allocateInstance方法

Object.clone 方法和反序列化通过直接复制已有的数据，来初始化新建对象的实例字段。Unsafe.allocateInstance 方法则没有初始化实例字段，而 new 语句和反射机制，则是通过调用构造器来初始化实例字段。



#### 压缩指针

在 Java 虚拟机中，每个 Java 对象都有一个对象头（object header），这个由**标记字段**和**类型指针**所构成。其中，标记字段用以存储 Java 虚拟机有关该对象的运行数据，如哈希码、GC 信息以及锁信息，而类型指针则指向该对象的类。

在 64 位的 Java 虚拟机中，**对象头的标记字段占 64 位，而类型指针又占了 64 位**。也就是说，每一个 Java 对象在内存中的额外开销就是 16 个字节。以 Integer 类为例，它仅有一个 int 类型的私有字段，占 4 个字节。因此，每一个 Integer 对象的额外内存开销至少是 400%。这也是为什么 Java 要引入基本类型的原因之一。

为了尽量减少对象的内存使用量，64 位 Java 虚拟机引入了压缩指针的概念（对应虚拟机选项 `-XX:+UseCompressedOops`，默认开启），将堆中原本 64 位的 Java 对象指针压缩成 32 位的。

这样一来，对象头中的类型指针也会被压缩成 32 位，使得对象头的大小从 16 字节降至 12 字节。当然，压缩指针不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段，以及引用类型数组。



#### 内存对齐

**内存对齐**（对应虚拟机选项` -XX:ObjectAlignmentInBytes`，默认值为 8）,Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数。如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为**对象间的填充（padding）**。

当然，就算是关闭了压缩指针，Java 虚拟机还是会进行内存对齐。此外，内存对齐不仅存在于对象与对象之间，也存在于对象中的字段之间。比如说，Java 虚拟机要求 long 字段、double 字段，以及非压缩指针状态下的引用字段地址为 8 的倍数。

**字段内存对齐的其中一个原因，是让字段只出现在同一 CPU 的缓存行中**。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。

#### 字段重排列

**字段重排列是 Java 虚拟机重新分配字段的先后顺序，以达到内存对齐的目的。**Java 虚拟机中有三种排列方法（对应 Java 虚拟机选项 -XX:FieldsAllocationStyle，默认值为 1），但都会遵循如下两个规则。

+ 其一，如果一个字段占据 C 个字节，那么该字段的偏移量需要对齐至 NC。这里偏移量指的是字段地址与对象的起始地址差值。
+ 其二，子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。



#### 参考

[链接](https://time.geekbang.org/column/article/13081)