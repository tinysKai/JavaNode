## MySQL - 索引

#### 定义

索引的目的是为了提高数据库查询效率.

#### 索引类型

+ 主键索引(聚簇索引),主键索引的叶子节点存储的是整行的数据
+ 非主键索引(二级索引),非主键索引的叶子节点存储的是对应主键的值

![https://s2.ax1x.com/2019/08/06/ehKiLQ.png](http://ww1.sinaimg.cn/large/8bb38904ly1g61t6econhj20vq0nsn1h.jpg)

#### 索引维护

​	使用b+tree索引时,数据添加以及减少可能会触发页分裂或者页合并.为有效减少这些高性能的操作,一般建议主键使用自增id来避免出现以上情况.然后由于字符串占用的字节数通常比长整数大(bigint占8个字节),所以使用bigint还能减少非主键索引的叶子节点的空间大小.

#### 索引选择B+tree的原因

​	能有效配合磁盘的特性,有效减少读取磁盘的次数,减少交互的时间

#### 覆盖索引

​	在使用非主键索引查询时,由于非主键索引的叶子节点存储的是主键值,因此需到主键索引查询具体的行记录,这个过程叫做回表.而使用覆盖索引可有效减少回表次数,提高次数,如以下示例,

```sql
-- 下面这条查询语句会先到f的索引查询每个符合的记录值id,然后再到主键索引查询具体的值
-- 如下面这个语句,依次遍历到3,4,5时都会去主键索引查询
select * from T where f between 3 and 5;

-- 优化
select * from T 
	where id in
    	(select id from T where f between 3 and 5);
```

#### 索引下推

联合索引下,若查询条件覆盖了联合索引的所有字段,则会判断所有条件后再回表.而不是一个个字段来判断回表的.如(name,age)的联合索引,mysql会在判断完name后再判断age值之后才决定是否回表.

#### 重建索引

`alter table T engine=InnoDB`使用该语句来重建索引比使用`alter table drop(add) index` 重建索引好.Innodb在仅删除了数据的情况下,索引对应的记录还是在的,数据库索引占用的空间并未释放.

#### change buffer

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在`change buffer`中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行`change buffer`中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。

change buffer适合于写多读少的业务,因为缓存的写数据越多,收益越大.而对于写完后经常伴随着一次查询业务,change buffer反而会使性能下降.

#### 唯一索引

查询时唯一索引和普通索引效率上基本没区别.

更新时唯一索引用不到`change buffer`,只有普通索引才能用上`change buffer`.

在执行更新语句时,若需更新的目标页不在内存中,则

+ 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
+ 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。

将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。

#### redo log && change buffer

​	redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗(更新数据时不使用change buffer需将磁盘数据加载到内存)。

​	`redo log`的作用是用于保证`crash safe`,正常情况下数据的最终落盘跟redo log没关系.如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。

​	`change buffer`解决的问题就是在**内存**中无对应的数据页时,先将更新操作缓存到`change buffer`中,稍后读取时再将缓存中的数据更新回去.

#### 修正索引

如果发现 explain 的结果预估的 rows 值跟实际情况差距比较大，可使用`analyze table ${tableName} `来修正统计里信息.

