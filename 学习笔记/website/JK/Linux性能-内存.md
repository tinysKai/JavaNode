## Linux性能-内存

#### 定义

内存主要用来存储系统和应用程序的指令、数据、缓存等。

通常所说的内存容量其实指的是物理内存。物理内存也称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM）。只有内核才可以直接访问物理内存。Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样，进程就可以很方便地访问内存，更确切地说是访问虚拟内存。

#### 虚拟地址

虚拟地址空间的内部又被分为**内核空间和用户空间**两部分，不同字长（也就是单个 CPU 指令可以处理数据的最大长度）的处理器，地址空间的范围也不同。

![https://s2.ax1x.com/2019/07/04/ZN1Q0g.png](http://ww1.sinaimg.cn/large/8bb38904ly1g4nfwsd0u8j20h80b0dgz.jpg)

#### 内存映射

内存映射，其实就是将**虚拟内存地址**映射到**物理内存地址**。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系

![https://s2.ax1x.com/2019/07/04/ZN13kj.png](http://ww1.sinaimg.cn/large/8bb38904ly1g4ng17x9bij20fu0aa3yp.jpg)



#### 虚拟内存空间分布

![https://s2.ax1x.com/2019/07/04/ZN1wBF.png](http://ww1.sinaimg.cn/large/8bb38904ly1g4ng47zt5mj207f09w3yl.jpg)

如上图用户空间内存，从低到高分别是五种不同的内存段。

1. 只读段，包括代码和常量等。
2. 数据段，包括全局变量等。
3. 堆，包括动态分配的内存，从低地址开始向上增长。
4. 文件映射段，包括动态库、共享内存等，从高地址开始向下增长。
5. 栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。

#### Linux回收内存的方式

- 回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；
- 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；
- 杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。



#### 查看内存

**free**

```shell
# 注意不同版本的 free 输出可能会有所不同
$ free
              total        used        free      shared  buff/cache   available
Mem:        8169348      263524     6875352         668     1030472     7611064
Swap:             0           0           0

# buff/cache 是缓存和缓冲区的大小
# available 是新进程可用内存的大小。
# available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。
```

**top**

```shell
# 按下 M 切换到内存排序
$ top
...
KiB Mem :  8169348 total,  6871440 free,   267096 used,  1030812 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  7607492 avail Mem


  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
  430 root      19  -1  122360  35588  23748 S   0.0  0.4   0:32.17 systemd-journal
 1075 root      20   0  771860  22744  11368 S   0.0  0.3   0:38.89 snapd
 1048 root      20   0  170904  17292   9488 S   0.0  0.2   0:00.24 networkd-dispat

# VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。虚拟内存通常并不会全部分配物理内存
# RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。
# SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。
# %MEM 是进程使用物理内存占系统总内存的百分比。
```

#### Buffer &  Cache

- Buffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。
- Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与 SReclaimable 之和。

`/proc 是 Linux 内核提供的一种特殊文件系统，是用户跟内核交互的接口。比方说，用户可以从 /proc 中查询内核的运行状态和配置选项，查询进程的运行状态、统计数据等，当然，你也可以通过 /proc 来修改内核的配置。`

**Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中**。

  磁盘是一个块设备，可以划分为不同的分区；在分区之上再创建文件系统，挂载到某个目录，之后才可以在这个目录中读写文件。其实 Linux 中“一切皆文件”，而上面提到的“文件”是普通文件，磁盘是块设备文件，这些大家可以执行 "ls -l <路径>" 查看它们的区别。

   在读写普通文件时，会经过文件系统，由文件系统负责与磁盘交互；而读写磁盘或者分区时，就会跳过文件系统，也就是所谓的“裸I/O“。这两种读写方式所使用的缓存是不同的，也就是文中所讲的 Cache 和 Buffer 区别。
  

#### 内存回收

在内存资源紧张时，Linux 通过直接内存回收和定期扫描的方式，来释放文件页和匿名页，以便把内存分配给更需要的进程使用。除了直接内存回收，还有一个专门的内核线程用来定期回收内存，也就是**kswapd0**。

`缓存和缓冲区`,它们在内存管理中,通常叫做**文件页(File-Page)**.大部分文件页，都可以直接回收，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。

脏页，一般可以通过两种方式写入磁盘 :

- 在应用程序中，通过系统调用 fsync ，把脏页同步到磁盘中；
- 由系统在内核线程 pdflush 负责这些脏页的刷新。

除了缓存和缓冲区，通过内存映射获取的文件映射页，也是一种常见的文件页。它也可以被释放掉，下次再访问的时候，从文件重新读取。

**匿名页**指应用程序动态分配的堆内存.

#### SWAP

Swap 说白了就是把一块磁盘空间或者一个本地文件当成内存来使用。它包括换出和换入两个过程。

- 换出就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存。
- 换入则是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。

#### 内存回收机制

回收的内存既包括了文件页，又包括了匿名页。

- 对文件页的回收，当然就是直接回收缓存，或者把脏页写回磁盘后再回收。
- 而对匿名页的回收，其实就是通过 Swap 机制，把它们写入磁盘后再释放内存。

Linux 提供了一个 /proc/sys/vm/swappiness 选项，用来调整使用 Swap 的积极程度。`swappiness` 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。

#### 内存查询指令

```shell
# 间隔 1 秒输出一组数据
# -r 表示显示内存使用情况，-S 表示显示 Swap 使用情况
$ sar -r -S 1
04:39:56    kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
04:39:57      6249676   6839824   1919632     23.50    740512     67316   1691736     10.22    815156    841868         4

04:39:56    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad
04:39:57      8388604         0      0.00         0      0.00


# kbcommit，表示当前系统负载需要的内存。它实际上是为了保证系统内存不溢出，
#     对需要内存的估计值。%commit，就是这个值相对总内存的百分比。

# kbactive，表示活跃内存，也就是最近使用过的内存，一般不会被系统回收。

# kbinact，表示非活跃内存，也就是不常访问的内存，有可能会被系统回收。
```

