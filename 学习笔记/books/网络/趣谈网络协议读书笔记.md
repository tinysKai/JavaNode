# 趣谈网络协议读书笔记

### 网络协议总览

![net](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110601.png)



### 地址分配

**32位IP地址分配**

![net](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110602.png)

**A,B,C类地址包含的主机量**

![net](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110603.png)

 

**无类型域间选路（CIDR）**

将 32 位的 IP 地址一分为二，前面是`网络号`，后面是`主机号`

```
比如10.100.122.2/24，这个 IP 地址中有一个斜杠，斜杠后面有个数字 24。
这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。
```

伴随着 CIDR 存在的，一个是`广播地址`，`10.100.122.255`。
如果发送这个地址，所有 `10.100.122` 网络里面的机器都可以收到。
另一个是`子网掩码`，`255.255.255.0`。



**网络号**

将子网掩码和 IP 地址按位计算 AND，就可得到网络号。 

如上的255.255.255.0与10.100.122.2的AND运算10.100.122.0就是网络号.



**私有地址**

192.168.0.x 是最常用的私有 IP 地址 .

192.168.0 是网络号，后面是主机号 .

整个网络里面的第一个地址 192.168.0.1，往往就是你这个私有网络的出口地址 

192.168.0.255 就是广播地址。一旦发送这个地址，整个 192.168.0 网络里面的所有机器都能收到 



**IP 是地址，有定位功能；MAC 是身份证，无定位功能**



### 动态主机配置协议（DHCP）

配置一段共享的 IP 地址。

每一台新接入的机器都通过 DHCP 协议，来这个共享的 IP 地址里申请，然后自动配置好 .

用完了，还回去，这样其他的机器也能用 

### 数据链路层

数据链路层也即MAC层主要解决以下问题 : 

- 这个包是发给谁的？谁应该接收？
- 大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？
- 如果发送的时候出现了错误，怎么办？(数据包的CRC校验)



控制数据包发送规则叫多路访问,主要有以下三种方式 : 

- 轮流协议
- 信道划分
- 随机接入协议(以太网就是这种方式)



**ARP协议**

已知IP地址求MAC地址的协议



### 如何解决广播问题和安全问题

- 物理隔离

- 虚拟隔离(VLAN)

  

使用 VLAN，一个交换机上会连属于多个局域网的机器，那交换机怎么区分哪个机器属于哪个局域网呢？

![net](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110701.png)

我们只需要在原来的二层的头上加一个 TAG，里面有一个 VLAN ID,一共12位



**ping 是基于 ICMP 协议工作的**.



**不改变 IP 地址的网关，我们称为`转发网关`;改变IP地址的我们称为`NAT网关`.**



### 路由协议

路由器就是一台网络设备，它有多张网卡。

当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为`路由表`



一张路由表中会有多条路由规则。每一条规则至少包含这三项信息

- 目的网络：这个包想去哪儿？ 
- 出口设备：将包从哪个口扔出去？
- 下一跳网关：下一个路由器的地址



动态路由算法

使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。

- 距离矢量路由算法
- 链路状态路由算法



动态路由协议

- 基于链路状态路由算法的 OSPF
- 基于距离矢量路由算法的 BGP

OSPF（Open Shortest Path First 开放式最短路径优先）就是这样一个基于链路状态路由协议，广泛应用在数据中心中的协议。由于主要用在数据中心内部，用于路由决策，因而称为`内部网关协议`（Interior Gateway Protocol，简称`IGP`）。内部网关协议的重点就是找到最短的路径。

BGP 协议使用的算法是`路径矢量路由协议`（path-vector protocol）。它是距离矢量路由协议的升级版。



BGP基于TCP，OSPF基于UDP .



### UDP协议

什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接.

所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。 



**UDP使用场景**

- 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用(DHCP)
- 不需要一对一沟通，建立连接，而是可以广播的应用
- 需要处理速度快，时延低，可以容忍少数丢包



### TCP协议

**TCP主要解决**

- 顺序问题(seq)
- 丢包问题(重传机制)
- 连接维护
- 流量控制
- 拥塞控制



**三次握手**

请求 -> 应答 -> 应答之应答

三次握手除了双方建立连接外,还有就是确认TCP包的问题

每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个 32 位的计数器，每 4ms 加一，如果计算一下，如果到重复，需要 4 个多小时 

握手时序图

![tcp](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110901.png)



**四次挥手**

客户端请求 -> 服务端应答半关闭 -> 服务端请求关闭 -> 客户端应答关闭

挥手时序图

![tcp](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110902.png)

**TCP状态机**

![tcp](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110903.png)



**累计应答**（**cumulative acknowledgment**） 

在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了.

**靠谱协议**

为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。

发送端

发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成以下四个部分,

1. 发送了并且已经确认的 
2. 发送了并且尚未确认的 
3. 没有发送，但是已经等待发送的 
4. 没有发送，并且暂时还不会发送的 

在 TCP 里，接收端会给发送端报一个窗口的大小，叫**Advertised window**。这个窗口的大小应该等于上面的第二部分加上第三部分。超过这个窗口的，接收端做不过来，就不能发送了。 

于是，发送端需要保持下面的数据结构。 

![tcp](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110904.png)



接收端

对于接收端来讲，它的缓存里记录的内容要简单一些。

第一部分：接受并且确认过的。

第二部分：还没接收，但是马上就能接收的。

第三部分：还没接收，也没法接收的。

对应的数据结构就像这样。 ﻿﻿ 

![tcp](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110905.png)

- MaxRcvBuffer：最大缓存的量；
- LastByteRead 之后是已经接收了，但是还没被应用层读取的；
- NextByteExpected 是第一部分和第二部分的分界线。

顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的

拥塞控制是通过拥塞窗口来解决的



### Socket 调用过程

**基于 TCP 协议的 Socket 程序函数调用过程**

在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回`另一个 Socket`。 

这是一个经常考的知识点，就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作**监听 Socket**，一个叫作**已连接 Socket**。 

基于TCP的socket程序函数调用过程

![tcp](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110906.png)

**基于 UDP 协议的 Socket 程序函数调用过程**

UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。 

基于 UDP 协议的 Socket 程序函数调用过程 

![udp](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110907.png)

HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能



**HTTPS交付图**

![https](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018110908.jpg)

### FTP协议

**FTP 采用两个 TCP 连接来传输一个文件**

- **控制连接**：服务器以被动的方式，打开众所周知用于 FTP 的端口 21，客户端则主动发起连接。该连接将命令从客户端传给服务器，并传回服务器的应答。常用的命令有：list——获取文件目录；reter——取一个文件；store——存一个文件。
- **数据连接**：每当一个文件在客户端与服务器之间传输时，就创建一个数据连接。



**FTP 的两种工作模式**

- 主动模式(PORT)
- 被动模式(PASV)

主动模式下，客户端随机打开一个大于 1024 的端口 N，向服务器的命令端口 21 发起连接，同时开放 N+1 端口监听，并向服务器发出 “port N+1” 命令，由服务器从自己的数据端口 20，主动连接到客户端指定的数据端口 N+1。

被动模式下，当开启一个 FTP 连接时，客户端打开两个任意的本地端口 N（大于 1024）和 N+1。第一个端口连接服务器的 21 端口，提交 PASV 命令。然后，服务器会开启一个任意的端口 P（大于 1024），返回“227 entering passive mode”消息，里面有 FTP 服务器开放的用来进行数据传输的端口。客户端收到消息取得端口号之后，会通过 N+1 号端口连接服务器的端口 P，然后在两个端口之间进行数据传输。



### DNS服务器

**分类**

- 根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址
- 顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址
- 权威 DNS 服务器 ：返回相应主机的 IP 地址



**树状层次结构**

![dns](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018111001.png)



**DNS解析流程**

![dns](https://github.com/tinysKai/Note/blob/master/image/article/2018/1012/2018111002.png)



**传统 DNS 存在的问题**

- 域名缓存问题
- 域名转发问题
- 出口 NAT 问题
- 域名更新问题
- 解析延迟问题

### HTTPDNS

HTTPNDS 不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。

这就相当于每家基于 HTTP 协议，自己实现自己的域名解析，自己做一个自己的地址簿，而不使用统一的地址簿。但是默认的域名解析都是走 DNS 的，因而使用 HTTPDNS 需要绕过默认的 DNS 路径，就不能使用默认的客户端。使用 HTTPDNS 的，往往是手机应用，需要在手机端嵌入支持 HTTPDNS 的客户端 SDK。



### **VPN**

全名Virtual Private Network，虚拟专用网，就是利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来

VPN 通过隧道技术在公众网络上仿真一条点到点的专线，是通过利用一种协议来传输另外一种协议的技术，这里面涉及三种协议：乘客协议、隧道协议和承载协议。