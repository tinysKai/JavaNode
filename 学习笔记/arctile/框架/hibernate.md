#### hibernate是什么,hibernate主要解决什么问题
Hibernate是一个对象关系映射(ORM)框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，
hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库


#### hibernate跟mybatis的区别



#### hibernate的会话状态
+ new/transient
+ persistent
+ detached
+ removed


#### 缓存
+ 一级缓存 : session级别的缓存..在session事务内可以通过id查询到数据..关闭session再依靠id查询数据会再发出查询语句的..
+ 二级缓存 : sessionFactory级别的缓存..主要设置只读级别的缓存....二级缓存只缓存对象...不缓存对象的部分属性..二级缓存不缓存hql语句,要解决此问题需开启查询缓存
    在整个sessionFactory内,对于非hql查询的数据是有缓存的...针对N+1问题,二级缓存可以简单有效的解决问题..
+ 查询缓存 : 使用hql时,使用查询缓存会缓存这些数据的id..但是如果不同时搭配二级缓存的话,只在session级别有效..使用二级缓存之后,依靠缓存的id和缓存的数据,可以做到不再发出查询数据...  
    使用查询缓存时务必开启二级缓存,不然极其容易造成N+1问题.  
    当你跨会话对同一个sql发出list的查询语句时,第一个sql的查询会让查询缓存生效缓存sql对应的对象id,而在另一个会话查询时由于查询缓存存在此时会直接得到对象id,但由于缓存中不存在对象具体数据,故又会发出N条数据去查询

N+1问题 : 在缓存外的范围使用依赖于id的查询会造成N+1问题...解决方法 : 使用二级缓存..


#### N+1问题
通过iterator()方法获取对象id后遍历这些对象时发发生N+1问题  
hibernate首先会发出1条sql去查询出所有对象的 id 值，当我们如果需要查询到某个对象的具体信息的时候，hibernate此时会根据查询出来的 id 值再发sql语句去从数据库中查询对象的信息，这就是典型的 N+1 的问题。  

使用list方法直接获取对象不会发生N+1问题. 
问题是既然list不会发生N+1问题为啥还会存在iterator方法? 当在同一个session会话中针对同一个sql进行两次查询时,如果两次都使用  
list方法是都可以查询出来,但这样完全不会使用到session缓存会有可能有性能问题.正确的方式是可以先使用list方法查询出全部对象,然后再使用iterator方法查询出id,迭代出全部对象(此时对象已经在session缓存中,不会发出SQL查询)

