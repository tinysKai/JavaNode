#### 锁类型
+ 偏向锁(当获取到锁的线程再次获取锁时,无需任务任何同步操作.适合并发量小的系统)
+ 轻量级锁(在进入互斥之前，使用CAS操作来尝试加锁，尽量不要用操作系统层面的互斥，提高了性能.在竞争非常激烈时（轻量级锁总是失败），轻量级锁会多做很多额外操作，导致性能下降)
+ 自旋锁(如果同步块很长，自旋失败，会降低系统性能。如果同步块很短，自旋成功，节省线程挂起切换时间，提升系统性能)

*文章 :https://my.oschina.net/hosee/blog/615865*


#### 什么是乐观锁,什么是悲观锁  
乐观锁，大多是基于version机制实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。
```
   select id ,field,version from table;
   update table set field ='' ,version = version + 1 where version = version and id = '';
   上面执行update语句返回记录数等于1则表示成功,否则为更新失败
```   
悲观锁,依靠数据库提供的锁机制,在整个数据处理过程中，将数据处于锁定状态
```
  select * from table where id = '' for update 
  在此事务提交前,筛选的数据都会锁定
```
   
#### 乐观锁,悲观锁的适用场景   
 因此： 
 1. 对于数据更新频繁的场合，悲观锁效率更高 
 2. 对于数据更新不频繁的场合，乐观锁效率更高


#### 锁优化的思路和方法
+ 减少锁持有时间(只加锁必须线程安全的模块,不要大范围加锁)
+ 减小锁粒度(减小锁粒度的案例就是ConcurrentHashMap)
+ 锁分离(读写锁ReadWriteLock)
+ 锁粗化 (加大锁持有时间,减少不必要的线程上下文交换)
+ 锁消除(jvm级别开启锁消除,-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks)


#### LOCK接口提供的synchronized关键字不具备的主要特性
+ 能响应中断
+ 尝试非阻塞性获取锁
+ 超时获取锁