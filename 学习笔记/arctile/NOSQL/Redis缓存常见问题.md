## Redis缓存常见问题

- 缓存击穿
- 缓存穿透
- 雪崩
- 缓存数据一致性

#### 缓存穿透

**定义**

​	指对应的key在后端的存储或者服务上肯定不存在，导致每次查询都会穿透缓存给回源通道带来很大的压力。

**解决方案**

1. 对Key进行合法性校验，过滤那些不合法的key
2. 使用布隆过滤器(guava已提供实现,有损,有误判)
3. 如果肯定不存在的key有规律,可使用缓存空标志的方案



#### 缓存击穿

**定义** 

​	指缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

  **解决方案**

​    加锁控制无缓存情况下的直接透传到数据库查询(缓存无数据时加锁再去查数据库,查询完设置回缓存再释放锁,空值也需要设置一个NULL标志缓存)

```java
public String get(key) {
      String value = redis.get(key);
      if (value == null) { //代表缓存值过期
          String key_mutex = key + "mutex";
          //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
		  if (jedis.set(key_mutex, "NX", "PX", 5) == 1) {  //代表设置成功
               value = db.get(key);
               //分布式锁,set + expire 5s
               jedis.set(key, value, "PX", 5000);
               //理论上不存在业务调用超时,业务敏感可使用lua脚本判断key来删除
               jedis.del(key_mutex);
           } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
               sleep(50);
               get(key);  //重试
           }
      } else {
           return value;      
      }
 }
```



#### 雪崩

**定义**

​	指在缓存不可用时(如服务宕机,服务无响应,同时间expire大量的key导致的无响应)，导致了应用线程的阻塞，进而导致了应用的不可用。或者全部穿透到后端的服务上导致后端的服务或者存储也不可用。

**解决方案**

1. 第一个问题的解决办法是通过合理的设置相关的超时和重试参数，让应用failfast
2. 评估QPS,必要时候降级处理

#### 缓存数据一致性

**定义** 

​	缓存与数据库值保持一致

**分析**

读的一致性基本没问题,都是先读缓存再查数据库再回写回缓存.缓存若不可用直接查询数据库数据还是准确的.

而更新操作就不一样,因为mysql跟redis的操作不在一个事务,无法原子的完成两个操作

因此,在此模式下,无法保证数据的高一致性,只能保证数据的最终一致性,开发人员需自己评判业务场景是否适合使用缓存,如涉及到交易,金额等强一致性的业务,则直接使用mysql.

分析两者的顺序情况下会出现的问题,jedis无法区分是宕机还是超时

- 方案一 : 先更新数据库后删除缓存,若更新完数据库成功后,删除缓存失败,则存在短时间的脏数据
- 方案二 : 先删除缓存再更新数据库,redis删除失败,则此时更新数据库后,数据不一致.并发场景下,线程A先删除缓存,准备更新数据库,此时缓存为空,而此时另一个线程B读取到缓存为空,准备去数据库读值并回写回缓存.而由于线程调度问题,线程B查询的数据库数据刚好在线程A更新数据库之前,则线程B回写完缓存的数据为脏数据,并且只能等待key过期(个人感觉此方案比方案一风险系数高)

**解决方案**

- 消费binlog来做增量更新redis,一开始全量redis缓存
- 在方案一的基础上,在更新数据库的同一个事务里面添加一条log操作来用来保证缓存最终一致性,方案如下
  - ![https://ws3.sinaimg.cn/large/005BYqpggy1g2ybcssiqzj30jp0frq4h.jpg](https://s2.ax1x.com/2019/05/12/EhPwdO.png)
- 高一致性性需维持缓存读写只能有一方在进行,需加锁,而这显然没直接使用mysql实际