## Redis的过期策略

#### 过期的Key集合

​    redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个字典来删除到期的 key



#### 清理机制

+ 定时清理
+ 惰性清除



#### 惰性清除

在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除。定时删除是集中处理，惰性删除是零散处理。



####  定时扫描策略

Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种`简单的贪心策略`。

```
定时清除key算法

1.从过期字典中随机 20 个 key；
2.删除这 20 个 key 中已经过期的 key；
3.如果过期的 key 比率超过 1/4，那就重复步骤 1；

同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。
```



当服务器恰好有大量key同一时间过期时,这是客户端请求过来查询时,可能需最长等待25ms.

而如果客户端的redis读超时时间设置为20ms,则大量的客户端请求会因为读超时而被关闭.

所以需对相同的一批次key在设置过期时间时加上`随机时间范围`来分散redis服务器处理的压力.



#### 从库的过期策略

从库不会进行过期扫描，从库对过期的处理是`被动`的。主库在 key 到期时，会在 AOF 文件里增加一条 `del` 指令，同步到所有的从库，从库通过执行这条 `del` 指令来删除过期的 key。

因为指令同步是`异步`进行的，所以主库过期的 key 的 `del` 指令没有及时同步到从库的话，会出现`主从数据的不一致`，主库没有的数据在从库里还存在，比如上一节的集群环境分布式锁的算法漏洞就是因为这个同步延迟产生的。



参考文章

<https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b4c42405188251b3950d251>