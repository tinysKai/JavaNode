## 数据库设计常见问题

**为什么字段类型越短越好？**

1. 更少的存储空间
2. 更少的磁盘IO
3. 更少的网络IO
4. 更少的MySQL计算空间
5. 更少的APP计算空间

**为什么要用自增ID做主键？（一定要有主键，并且用int/bigint做主键更好，如果自增ID那就完美了）**

1.MySQL InnoDB为索引组织表，即使你不设置主键系统也会维护一个隐藏的主键。

> 所有隐藏主键共享一个自增锁。如果很多表没主键，使用隐藏主键，这里是瓶颈。

 2.隐藏主键为一个6字节的整型，可能存在被写完而不被察觉的风险。

3.没有设置主键(隐藏主键没用)很多工具无法使用，例如online ddl(不锁表加索引，字段等表变更)会让日常维护变的复杂。

> 有多复杂？下午3点钟做变更和凌晨3点钟做变更的区别。或者周末大家一起到公司来做。

4.没有设置主键MySQL可能使用表上面的唯一索引作为主键，如果这个唯一索引很长，性能将特别差，详见下面条目5。一定要说差多少，10倍。

5.MySQL InnoDB为索引组织表，什么是索引组织表？

> 想一下英文字典，字典的每个词都是按照拼音组织的。第一页到最后一页从 a-a 到 z-z。
>
>  a.那么越短的单词越容易被查到。主键也是越短数据检索速度越快，user_name的长度是user_id十倍左右。所以要user_id做主键。一定要说差多少，10倍。
>
> b.MySQL InnoDB所有二级索引(普通索引)都包含主键，主键越长二级索引越大，如果二级索引也是个字典，相当于你需要翻更多的页查看一样多的数据。
>
>   c.那么新添加一个单词，想象下字典要怎么做？因为之前填满了单词，要把所在页面分成两页，再插入。
>
> ​    数据库也是这样，并且把一页分成两页系统*同一时刻只能做一个这个动作*，这里又是一个瓶颈。但如果按照先来后到写入就不用这样了
>
> 直接在字典最后留白写上就好了。自增ID永远都是先来的小，后来的大，先来后到写入，不存在这样的瓶颈。

6.自增ID可以用来做分页优化。

> 语句：select * from message limit 10000000,30;
>
>   和：select * from message where id>10000000 limit 30;
>
>   性能相差1000倍，甚至更多。甚至会被人利用做CC攻击。

  

**字段类型选择**

**数字类型：**

| **类型**    | **有符号取值范围**                          | **无符号取值范围(unsigned)** | **占用字节数** | **默认值** | **额外说明** |
| ----------- | ------------------------------------------- | ---------------------------- | -------------- | ---------- | ------------ |
| tinyint     | -128 到 127                                 | 0 到 255                     | 1字节          | 0          | 无           |
| smallint    | -32768 到 32767                             | 0 到 65535                   | 2字节          | 0          | 无           |
| mediumint   | -8388608 到 8388607                         | 0 到 16777215                | 3字节          | 0          | 无           |
| int/integer | -2147483648 到 2147483647                   | 0 到 4294967295              | 4字节          | 0          | 无           |
| bigint      | -9223372036854775808 到 9223372036854775807 | 0 到 18446744073709551615    | 8字节          | 0          | 无           |

**字符类型：**

| **类型**     | **取值范围**    | **占用字节数**                                               | **默认值** | **额外说明**                                 |
| ------------ | --------------- | ------------------------------------------------------------ | ---------- | -------------------------------------------- |
| char(n)      | 可以存储n个字符 | 跟字符集相关，线上统一utf8，utf8为变长字符集，因为数字1字节，汉字3字节，不够n字符，补充空格 | ''         | 不要使用char，用varchar代替(原因详见下5)     |
| varchar(n)   | 可以存储n个字符 | 跟字符集相关，线上统一utf8，utf8为变长字符集，因为数字1字节，汉字3字节 | ''         |                                              |
| binary(n)    | 可以存储n个字节 | binary没字符集概念，存储长度等于n字节。                      | ''         | 不要使用binary，用varbinary代替(原因详见下5) |
| varbinary(n) | 可以存储n个字节 | binary没字符集概念，存储长度等于数据长度。                   | ''         |                                              |

**LOB类型(大文本，大对象)：**

| **类型**   | **取值范围**                    | **占用字节数**                                               | **默认值**     | **额外说明**                    |
| ---------- | ------------------------------- | ------------------------------------------------------------ | -------------- | ------------------------------- |
| tinytext   | 最大 255 字节 数据              | 跟字符集相关，线上统一utf8，utf8为变长字符集，因为数字1字节，汉字3字节 | 不用设置默认值 | 非万不得已不要使用(原因详见下7) |
| text       | 最大 65535 字节 或65K 数据      | 跟字符集相关，线上统一utf8，utf8为变长字符集，因为数字1字节，汉字3字节 | 不用设置默认值 | 非万不得已不要使用(原因详见下7) |
| mediumtext | 最大 16777215 字节 或 16M 数据  | 跟字符集相关，线上统一utf8，utf8为变长字符集，因为数字1字节，汉字3字节 | 不用设置默认值 | 非万不得已不要使用(原因详见下7) |
| longtext   | 最大 4294967295字节 或 4GB 数据 | 跟字符集相关，线上统一utf8，utf8为变长字符集，因为数字1字节，汉字3字节 | 不用设置默认值 | 非万不得已不要使用(原因详见下7) |
| tinyblob   | 最大 255 字节 数据              | blob没字符集概念，存储长度等于数据长度。                     | 不用设置默认值 | 非万不得已不要使用(原因详见下7) |
| blob       | 最大 65535 字节 或65K 数据      | blob没字符集概念，存储长度等于数据长度。                     | 不用设置默认值 | 非万不得已不要使用(原因详见下7) |
| mediumblob | 最大 16777215 字节 或 16M 数据  | blob没字符集概念，存储长度等于数据长度。                     | 不用设置默认值 | 非万不得已不要使用(原因详见下7) |
| longblob   | 最大 4294967295字节 或 4GB 数据 | blob没字符集概念，存储长度等于数据长度。                     | 不用设置默认值 | 非万不得已不要使用(原因详见下7) |

**时间、日期：**

| **类型**  | **取值范围**                               | **占用字节数** | **默认值**                    | **额外说明**                       |
| --------- | ------------------------------------------ | -------------- | ----------------------------- | ---------------------------------- |
| year      | 1901 到 2155                               | 1字节          | default '0000'                | 一般不使用                         |
| data      | 1000-01-01 到 9999-12-31                   | 3字节          | default '0000-00-00'          | 推荐用来存生日，订单日期这样的数据 |
| time      | -838:59:59 到 838:59:59                    | 3字节          | default '00:00:00'            | 一般不使用                         |
| datetime  | 1000-01-01 00:00:00 到 9999-12-31 23:59:59 | 8字节          | default '0000-00-00 00:00:00' | 建议使用timestamp存储时间          |
| timestamp | 1970-01-01 00:00:01 到 2038-01-19 03:14:07 | 4字节          | default '0000-00-00 00:00:00' | 推荐使用timestamp存储时间          |

**小数：**

| **类型**                 | **取值范围** | **占用字节数**                                   | **默认值** | **额外说明**                            |
| ------------------------ | ------------ | ------------------------------------------------ | ---------- | --------------------------------------- |
| float                    | 见文档       | 4字节                                            | 0.0        | 精度问题不建议使用                      |
| double                   | 见文档       | 8字节                                            | 0.0        | 精度问题不建议使用                      |
| decmal(m,n)/numerci(m,n) | 见文档       | 如果有小数部分：m+2字节，如果没小数部分：m+1字节 | 0.0        | 请设置合理长度或用整数来存(1.23*10=123) |

**其他：**

| **类型** | **取值范围** | **占用字节数** | **默认值** | **额外说明**   |
| -------- | ------------ | -------------- | ---------- | -------------- |
| bit      | 见文档       |                |            | 请不要使用     |
| set      | 见文档       |                |            | 请不要使用     |
| enum     | 见文档       |                |            | 请尽量不要使用 |



**怎样存储IP？**

**对于IPv4：**

> 经常看到一些同学使用varchar(15)或者char(15)来存储IP，须不知：
>
> 因为IPv4实际上就是一个4字节长度的数据，因此我们可以使用 int unsigned (4字节无符号)来存储IPv4
>
> 把IP转换成int来存储有许多好处：1.数据体积降低，int存只需要4字节，varchar需要16字节，对应的索引长度也是4倍的差距。 2.索引长度降低、检索效率更高。
>
> MySQL自身就带有函数INET_ATON和INET_NTOA可以把IPv4转换成一个整数和把正数转换成IPv4：
>
> 

```shell
dba@localhost : vipshop_dba 17:29:56> select inet_aton('192.168.111.111');
+------------------------------+
| inet_aton('192.168.111.111') |
+------------------------------+
| 3232264047 |
+------------------------------+
dba@localhost : vipshop_dba 17:29:57> select inet_ntoa(3232264047);
+-----------------------+
| inet_ntoa(3232264047) |
+-----------------------+
| 192.168.111.111 |
+-----------------------+
```

> **对于IPv6：**
>
> 如果你需要存储IPv6请找DBA商量决定怎么存储。



**MySQL中的 DATETIME 与 TIMESTAMP 的相同和不同**

**相同**

> 显示：
>
> TIMESTAMP与DATETIME显示格式相同。也即：显示宽度固定在19字符，格式为：YYYY-MM-DD HH:MM:SS。
>
> 查询：
>
> TIMESTAMP与DATETIME查询格式相同。也即：都是以 column_name='YYYY-MM-DD HH:MM:SS' 或 column_name>='YYYY-MM-DD HH:MM:SS' 格式查询。



**不同**

>范围：
>
>DATETIME ：支持的范围为 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59' 。DEFATUL值可以设置为范围内任意值，如 DEFAULT '1000-01-01 00:00:00'
>
>TIMESTAMP：支持的范围为 '1970-01-01 00:00:00' UTC 到 '2038-01-19 03:14:07' UTC 。DEFATUL值可以设置为范围内任意值，还可以设置 DEFAULT '0000-00-00 00:00:00'
>
>
>
>TIMESTAMP储存：
>
>1.4个字节储存
>
>2.以UTC（Universal Time Coordinated，通用协调时）格式保存。
>
>3.时区转化 ，因为以以UTC格式保存，因此存储时转换成UTC，查询时根据MySQL会话时区设置转换回当前的时区（因此读到的结果跟MySQL会话时区相关，一般没影响）。
>
>
>
>DATETIME储存：
>
>1.8个字节储存，是TIMESTAMP的一倍。
>
>2.实际格式储存，存的什么就写什么。
>
>3.与时区无关，存的什么就读到什么。



**TIMESTAMP 的一些其他的属性**

> 1.字段不能定义DEFAULT NULL，也不能写入NULL(写入NULL会被转换成CURRENT_TIMESTAMP，或者DEFAULT值)。
>
> 2.TIMESTAMP字段个数的问题：
>
> a.DEFAULT值为'0000-00-00 00：00：00'或'2008-01-01 12:12:12'等具体具体数值的TIMESTAMP字段可以有随意个数。
>
> b.没有DEFAULT值或者设置如下DEFAULT值，一个表中只能有一个：
>
> i.不设置 DEFAULT 值 （不设置 DEFAULT 值等同于 DEFAULT CURRENT_TIMESTAMP） 
>
> ii.DEFAULT CURRENT_TIMESTAMP 
>
> iii.DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

 

**关于使用 int 直接存储 unix时间戳 的方式存储时间：**

> 因为 unix时间戳 实际是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数(不考虑闰秒，timestamp底层实际就是存储这一秒数)。
>
> 所以很多同学直接用 int unsigned(跟timestamp一样，4字节无符号)来存储 unix时间戳 的方式来存储时间。
>
> 相对于 timestamp 和 datetime **用 int unsigned来存储 unix时间戳 的方式来存储时间有什么优缺点呢？**
>
> 优点：
>
> ​     1.方便时间计算，直接 +/— 就能算出两个时间相差的秒数。
>
> 缺点：
>
> ​      1.读取不方便，还需要转换一次才能得到人类能读懂的日期形式 YYYY-MM-DD HH:MM:SS ，但转换还算方便，MySQL 函数 from_unixtime(timestamp) 就能转换。
>
> ​      2.功能相对于 timestamp 弱很多，不能 DEFAULT CURRENT_TIMESTAMP 或 DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP。



**总结：**

> 1.当对范围没有要求的时候 DATETIME 和 TIMESTAMP 使用一模一样，但是TIMESTAMP具有更省空间、更强功能等诸多特点，强烈建议以 TIMESTAMP 替换 DATETIME。
>
> 2.使用 int unsigned 存储时间戳的方式来存储时间不反对也不推荐(更推荐timestamp)，但使用的时候注意比较也要跟 unix时间戳 进行比较如果跟 YYYY-MM-DD HH:MM:SS 进行比较可能走不上索引而进行全部扫描。



提醒(1)：关于InnoDB存储引擎

> 作为一个**更先进成熟**的存储引擎，InnoDB有：事务型引擎、支持行锁、支持MVCC、支持崩溃恢复、更高效的IO、更先进的缓存，写策略等优点。
>
> 因此我们线上**原则上所有表都统一使用InnoDB存储引擎**。



提醒(2)：关于InnoDB主键，一定要设定主键

> MySQL InnoDB为索引组织表，即使你不设置主键系统也会维护一个隐藏的主键。所有隐藏主键共享一个自增锁。
>
> 如果很多表没主键，使用隐藏主键，这里是瓶颈。隐藏主键为一个6字节的整型，可能存在被写完而不被察觉的风险。

提醒(3)：关于主键类型要用整型bigint无符号(unsigned)

> InnoDB所有二级索引的结构都是索引字段本身后面跟着主键，因此主键越短越好
>
> 因此一般建议不要使用username,uuid等字符串类型作为主键，而是使用整型(tinyint,smallint,mediumint,int,bigint)作为主键。
>
> 所有表的主键都必须是自增bigint unsigned：**int无符号最大存储空间约为42亿，在以往的工作中我们曾经出现过多次因为自增主键用完而造成丢失数据的问题，所以我们要求所有表的自增ID都必须使用bigint unsigned**

提醒(4)：关于自增主键

>  也因为InnoDB为一个索引组织表，为了防止页分裂，我们强烈建议使用自增整型作为主键。



提醒(5)：不要使用char，用varchar代替

> 对于innodb数据表，内部的行存储格式没有区分固定长度和可变长度列（所有的数据行都指向数据列值的头指针）。
>
> 因此使用固定长度的char数据类型不一定比使用可变数据长度的数据类型性能好。
>
> 因而，主要的性能因素是数据行使用的存储总量，由于char数据列占用的空间比varchar数据列要大，因此varchar存储的空间要小，对于磁盘io来说越小的空间，处理数据能力越强。
>
> 另：char(n)，varchar(n)里面的n表示n个字符，不是n字节。

提醒(6)：用tinyint代替enum、set等存储状态、分类等

> 相对于enum和set，tinyint更容易扩展（完全不用做DDL就可以增加一个状态、分类等等。）。MySQL查询和处理的效果也更佳。

提醒(7)：避免使用tinytext、text

> 非万不得已不要使用 TEXT 数据类型，其处理方式决定了他的性能要低于char或者是varchar类型的处理。
>
> 且tinytext最大存储255个字节（不是字符），text最大存储65535个字节，varchar最大也可以存储65536个字节的数据。因此大多能使用tinytext、text的地方都可以用更高性能的varchar代替。
>
> 如果你的数据 varchar 存放不下，那么 text 估计也保存不下，你可能需要的是 mediumtext(16M) 或 longtext(4G)。
>
> **如果一个表中有特别大的字段，为了性能强烈建议把 list页面会用到的小字段数据 和 detail页面会用到的大字段数据 分表存放。**

提醒(8)：不要使用tinyblob、blob、mediumblob、longblob等二进制lob类型

> 强烈反对在数据库中存放 二进制 LOB 类型数据，虽然数据库提供了这样的功能，但这不是他所擅长的。

提醒(9)：太长的varchar

> 你真的需要这么长的varchar吗？
>
> 更长的列定义宽度可能会造成：
>
> 1.当使用临时表的时候每行需要更多的内存（按表定义申请内存），如果临时表最大内存用完会造成磁盘临时表的出现。
>
> 2.当不能使用索引排序的时候可能会影响排序算法，造成额外的IO开销。
>
> 注意：因为有的时候我们必须存储大段文本必须用到大的varchar，但是我们希望你能根据数据样本尽量优化，约接近实际数据长度越好。
>
> 另：char(n)，varchar(n)里面的n表示n个字符，不是n字节。
>
> **如果一个表中有特别大的字段，为了性能强烈建议把 list页面会用到的小字段数据 和 detail页面会用到的大字段数据 分表存放。**

提醒(10)：int(1)和int(100)的区别

> 有别于char(x)和varchar(x)，int(x)中的x表示的是整型(tinyint smallint mediumint int bigint)在添加了zerofill描述符后的显示宽度。
>
> 所以**在不添加zerofill描述符的时候， int(1) 和 int(10) int(100) 都没什么区别**都占用4字节，都能存储 -21亿 到 +21亿 这个范围内的数据。
>
> **如你表示你只想存储这么短的数字（状态、类型、标志位等数据用tinyint -128到127 一般足够**）用不完4字节你可以选用tinyint、smallint、mediumint。
>
> **注意：**定义整型(tinyint、smallint、mediumint、int、bigint)的时候，如果没有zerofill可以完全不用定义长度，如： user_id int not null default '0'。
>
> **整型字段有个ZEROFILL属性，在数字长度不够的数据前面填充0，以达到设定的长度**
>
> 注:当使用zerofill 时，默认会自动加unsigned（无符号）属性，使用unsigned属性后，数值范围是原值的2倍，例如，有符号为-128~+127，无符号为0~256。

提醒(11)：怎样存储日期和时间呢？

> 尽量使用TIMESTAMP类型，因为其存储空间只需要 DATETIME 类型的一半(timestamp 4字节，datetime 8字节)。
>
> 而且功能还比 DATETIME 强大的多，比如：DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP。
>
> 对于只需要精确到某一天的数据类型，建议使用DATE类型，因为他的存储空间只需要3个字节，比TIMESTAMP还少，更不用说datetime。
>
> 不建议通过INT类型类存储一个unix timestamp 的值，因为这太不直观，会给维护带来不必要的麻烦，同时还不会带来任何好处。还会损失timestamp的auto update等等功能。

提醒(12)：怎样存储小数（小数点）呢？

> 非万不得已不要使用DOUBLE，不仅仅只是存储长度的问题，同时还会存在精确性的问题。
>
> 同样，固定精度的小数，也不建议使用DECIMAL，建议乘以固定倍数转换成整数存储，可以大大节省存储空间，且不会带来任何附加维护成本。
>
> **说明：**货币的存储如果确实不能转化为整型，还是推荐使用 decimal 存储。

提醒(13)：请不用default null，为了防止多个系统共用的表被别人写入null，最好定义not nll！

> NULL 类型比较特殊，SQL 难优化。虽然 MySQL NULL类型和 Oracle 的NULL 有差异，会进入索引中，但如果是一个组合索引，那么这个NULL 类型的字段会极大影响整个索引的效率。
>
> 此外，NULL 在索引中的处理也是特殊的，也会占用额外的存放空间。
>
> 很多人觉得 NULL 会节省一些空间，所以尽量让NULL来达到节省IO的目的，但是大部分时候这会适得其反，虽然空间上可能确实有一定节省，倒是带来了很多其他的优化问题，不但没有将IO量省下来，反而加大了SQL的IO量。
>
> 所以尽量确保 DEFAULT 值不是 NULL，也是一个很好的表结构设计优化习惯。

提醒(14)：定义NOT NULL必须设置默认值！

> 定义NOT NULL必须设置默认值，防止SQL里面没带改字段的时候SQL无法成功执行。

提醒(15)：线上统一使用utf8字符集和utf8_general_ci校对

> 线上统一使用utf8字符集和utf8_general_ci校对，为了不给你和其他系统带来乱码问题，请也使用utf8字符集和utf8_general_ci校对。

提醒(16)：每个表都得有 create_time 和 update_time (如果永远不update则不需要) 字段。

> 每一行数据都应该有自己的创建时间(create_time)和最后更新时间(update_time)，我们要求所有表都得有create_time 和 update_time 字段。
>
> 并且最好 create_time 由应用程序维护，不能修改。update_time 由MySQL维护(使用timestamp字段类型的功能)，如下：

```sql
CREATE TABLE `must_have` (
`id` int(10) NOT NULL AUTO_INCREMENT,
`create_time` timestamp NOT NULL DEFAULT '1971-01-01 00:00:00', -- 程序维护，不可更改
`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,-- MySQL维护
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ;
```

> 如果你表中已经有了该类功能的字段，只是名称不一样，为了统一我们建议你使用如上名称——create_time 和 update_time。
>
> **如下情况可以特殊处理，请在最终发给DBA Review的时候说明：**
>
> 1.该表为一个静态表，数据量很小、变动很小。
>
> 2.该表本来就只INSERT不更新，比如日志表。

提醒(17)：所有数据都不能物理删除(delete from tab where id=xx)，必须以标志位的形式软删除(update tab set is_deleted=1 where id=xx)(如果永远不删除则不需要)。

> 这一要求主要基于如下考虑：
>
> 1.软删除性能远优于物理删除。
>
> 2.如果数据有问题物理删除追溯的难度远大于软删除。
>
> 3.物理删除对于需要获得实时数据状态变化的业务无异于噩梦，比如 BI抽数、推荐算法增量计算 等等。
>
> 因此我们要求所有表、所有数据都不能物理删除(delete from tab where id=xx)，必须以标志位的形式软删除(update tab set is_deleted=1 where id=xx)。
>
> 如果你表中已经有了该类功能的字段，只是名称不一样，为了统一我们建议你使用如上名称——is_deleted。
>
> **如下情况可以特殊处理，请在最终发给DBA Review的时候说明：**
>
> 1.该表为一个静态表，数据量很小、变动很小。
>
> 2.该表本来就只INSERT不删除，比如日志表。
>
> 3.有类似功能并且功能远大于表达是否删除的字段的表，如：orders.status=5 为成功支付订单，orders.status=10 为已完成订单，orders.status=-100 为已删除订单。



提醒(19)：字段名里面不能包含空格，原则上表名字段名全部用小写

> 字段名里面不能包含空格，原则上表名字段名全部用小写

提醒(20)：表名长度不允许超过40个字符

> **为了运维工具的正常运行**表名长度不允许超过40个字符。

提醒(99)：不允许调整字段顺序

> 为了整体系统的健壮我们不允许调整字段的顺序

提醒(100)：不允许删除字段、索引，不允许重命名字段、表。

> 为了整体系统的健壮我们不允许删除字段、索引，不允许重命名字段。如果一定要删除（例如：唯一索引的唯一维度改变需要删除老的唯一索引）
>
> 修改字段的方式为 ALTER TABLE MODIFY xxx 而不是 ALTER TABLE CHANGE xxx



