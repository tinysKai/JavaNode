##  Redis与DB双写一致性

### 前提

给缓存设置过期时间，是**保证数据最终一致性**的必要条件：

- 对存入缓存的数据设置过期时间：所有的写操作以数据库为准
- 对缓存操作只是尽最大努力即可：如果数据库写成功，缓存更新失败，那么后面读的请求将从数据库读取更新值再加载到缓存中

### 策略

- 先更新数据库，再更新缓存 —— 策略1
- 先删除缓存，再更新数据库 —— 策略2
- 先更新数据库，再删除缓存 —— 策略3

### 分析

#### 策略1

策略1和策略3的区别在于对于缓存操作上（是更新缓存还是删除缓存），**更新缓存存在问题**：

1. **线程安全角度**：
   - 线程A更新了数据库
   - 线程B更新了数据库
   - 线程B更新了缓存
   - 线程A更新了缓存
     —— 由于网络原因，B可能比A更早的更新了缓存，那么将导致了脏数据
2. **业务场景角度**：

- - 写多读少：若写多读少、则造成缓存更新频繁、浪费性能
  - 经复杂运算处理的：即每次写DB后还要经过复杂运算写缓存，则浪费性能

#### 策略2

策略2即针对策略1存在的问题：脏数据且性能可能浪费，但**删除缓存仍存在问题：**

1. **线程安全角度**：请求A—更新操作、请求B—查询操作 

   - 请求A进行写操作，删除缓存
   - 请求B查询发现缓存不存在：从数据库查询到旧值、然后写入缓存
   - 请求A将新值写入数据库
     —— **上述造成在缓存未失效期间，DB与缓存的数据是不一致的**

   - 延迟双删除
     - 主要针对“请求A写入新值到DB”的改进：延迟阈值（如1S、500ms）后再触发删除缓存

2. **延迟双删仍存在问题**： 请求A---更新操作、请求B—查询操作

   - **阈值设置不太精准**：

     - 在读数据业务逻辑耗时上加几百毫秒——确保读请求结束后写请求可删除读请求造成的缓存脏数据

   - **漏洞1**：

      主要问题场景

     - 请求A进行写操作，先删除缓存
     - 请求B查询发现缓存不存在：请求B去数据库查询得到旧值、请求B将旧值写入缓存
     - 请求A将新值写入数据库：请求A试图去删除请求B写入的缓存值（即旧值），结果失败

   - **漏洞2**：若DB是读写分离结构

     - 请求A进行写操作，删除缓存：请求A将数据写入数据库
     - 请求B查询缓存发现，缓存没有值：请求B去从库查询，此时还没有完成主从同步（可能），因此查询到的是旧值
     - 请求B将旧值写入缓存：数据库完成主从同步，从库变为新值
       ——**即在主从同步期间、仍然存在缓存与DB不一致的问题**

#### 策略3

策略3：既然策略1和策略2均存在问题，那么只有策略三：即先将数据更新成功DB后再让缓存失效（删除），剩下一个问题：

若缓存失效处理（即删除）异常怎么办 ——有下述两种思路供**参考使用**：

1. 启用缓存事务

   ： 

   即DB更新与缓存删除强一致

    

   - 即服务层事务范围涉及DB事务与Redis事务——Redis事务加入到当前DB事务中：

     - 若DB事务未正常提交则Redis事务不会进行，保证一致性
     - 若Redis事务未成功提交则不会删除数据、且异常上抛后将触发DB事务的回滚，保证一致性

   - 方案局限性

     ：

     - Redis仅有事务命令没有类似本地事务的Commit及RollBack，上述需借助Redisson框架完成

     - 由于Redis事务是在本地事务传播范围内——其处理快慢对整体事务有影响（如网络卡顿、因此需设置Redis事务超时时间）

     - 更多适合读多更新少的场景——若缓存更新频繁则不建议使用

       

2. **不启用缓存事务**：借助保障重试的机制来实现缓存删除（即最大努力）

   - 前提：
     - 下述方案将**放弃DB更新与缓存删除的强一致**，即容忍缓存删除成功前存在的DB与缓存的不一致性（缓存还未失效）
     - 分为“消息队列方式”以及“BINLOG驱动方式”

- - 消息队列方式

    - 若缓存删除失败（也可借助Redisson的事务机制），则将需删除的KEY发送到消息队列

    - 业务应用自己消费上述消息队列数据（如监听该队列），获取删除的KEY后继续执行删除操作——直到成功

    - 方案局限性

      - 对业务代码本身造成了侵入（即感知删除KEY失败带来的影响）

        

  - BINLOG驱动方式

    - 借助CANAL等BINLOG中间件，获得需要操作的数据
    - BINLOG订阅：通过上述中间件获取相关DB更新，并从其获得更新数据、删除的KEY值
    - 缓存删除驱动：
      - 独立于业务代码处理，该模块获得BINLOG订阅信息，再触发缓存的删除
      - 若上述删除失败，则再投递给到消息队列、然后再驱动缓存删除——直到成功
    - 方案局限性
      - 需与CANAL做集成（存在一定工作量）、优点是解耦了应用代码的入侵

### 参考链接

[reddison事务](https://github.com/redisson/redisson/wiki/10.-%E9%A2%9D%E5%A4%96%E5%8A%9F%E8%83%BD)

[spring数据库事务与redis事务](https://www.lovecto.cn/20180822/226.html)