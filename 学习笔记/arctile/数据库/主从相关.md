#### 主从复制
mysql使用3个线程来执行复制功能,其中1个在主服务器上，另两个在从服务器上.  
从服务之所以有两个线程是因为需要将接收和解析两个动作分开,减少主崩溃时得数据丢失(接收数据比解析数据快很多)
+ dump线程 主服务器上负责将binlog发送到从服务器
+ IO线程   负责接收主发送过来的信息并将其写进relay log
+ SQL线程  将relay log解析执行


当发出start slave时，从服务器创建一个I/O线程，以连接主服务器并让它发送记录在其二进制日志中的语句。  
主服务器创建一个线程将二进制日志中的内容发送到从服务器。该线程可以即为主服务器上show processlist输出中的Binlog Dump线程。  
从服务器I/O线程读取主服务器Binlog Dump线程发送的内容并将该数据拷贝到从服务器数据目录中的本地文件中，即中继日志。  
第3个线程是sql线程，由从服务器创建，用于读取中继日志并执行日志中包含的更新。在从服务器上，读取和执行更新语句被分成两个独立的任务。当从服务器启动时，其I/O线程可以很快地从主服务器索取所有二进制日志内容。
![binlog](https://github.com/tinysKai/JavaNote/blob/master/image/article/2018/0709//binlog.JPG)


#### 主从复制机制
+ 异步复制(MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理)
+ 全同步复制(指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。)
+ 半同步复制(介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端)  

>半同步复制  
![btree](https://github.com/tinysKai/JavaNote/blob/master/image/article/2018/0709//replication.jpg)
  
>半同步复制存在的问题
客户端事务在存储引擎层提交后，在得到从库确认的过程中，主库宕机了，此时，可能的情况有两种

 + 事务还没发送到从库上
     客户端会收到事务提交失败的信息，客户端会重新提交该事务到新的主上，当宕机的主库重新启动后，以从库的身份重新加入到该主从结构中，会发现，该事务在从库中被提交了两次，一次是之前作为主的时候，一次是被新主同步过来的。
+ 事务已经发送到从库上  
     从库已经收到并应用了该事务，但是客户端仍然会收到事务提交失败的信息，重新提交该事务到新的主上。
  

>无数据丢失的半同步复制  
针对上述潜在问题，MySQL 5.7引入了一种新的半同步方案：Loss-Less半同步复制。  
针对上面这个图，“Waiting Slave dump”被调整到“Storage Commit”之前。


#### binlog模式
+ row 只记录每一行被修改的数据(清楚,容易理解,可能产生大量的日志内容)
+ statement 记录执行的sql(节省了IO以及存储资源,提高了性能,有较大的bug问题)
+ mixed 会根据执行的SQL来选择是row模式还是statement模式