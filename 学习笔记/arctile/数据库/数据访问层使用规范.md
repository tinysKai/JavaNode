# 缓存

## 存储选型

 

公司大量系统使用缓存进行加速，目前在用的缓存类型众多，主要有共享缓存和本地缓存，同时缓存架构上又有多种选择。面对如此众多的方案，业务很难非常高效且准确的选择一个合适的缓存方案。本节将通过给出每种方案的各种详细的技术指标及真实案例供业务在选择时进行参考。

### 类型选型

目前主要在用的缓存类型有共享缓存和本地缓存，相关缓存类型的主要技术指标如下：

| 缓存类型  | 单实例QPS | 高可用                                      | 一致性                           | 扩展性                                                     | 适用场景                                                     | 存在的问题                                                   |
| --------- | --------- | ------------------------------------------- | -------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 本地缓存  | 1000K     | 无                                          | 无（部分开源框架也支持弱一致性） | 无（受限于物理内存）                                       | 热键：共享缓存的单实例无法支撑，如QPS大于20W数据聚合：如需要跨节点mget访问Redis集群高吞吐量低延迟：存在不太需要变化的数据，但需要较大的访问量且对延迟比较敏感 | 业务需要容忍本地缓存之间的数据一致性的问题缓存与后端存储之间的数据同步较为复杂，推荐通过VMS组内广播实现。 |
| Redis     | 50~80K    | 有（切换时间为30s到几分钟，取决于部署架构） | 弱（异步Replication)             | 可以横向扩展                                               | 复杂的数据结构：非简单的key-value较高的可用性、持久性和一致性的需求 | Redis是非强一致性的系统，所以通过redis实现类似分布式锁的方案可能在极端情况下会有多个节点拿到锁的可能，业务需要慎重。 |
| Memcached | 200K      | 无（由客户端保证）                          | 无                               | 可以横向扩展但是原来节点上的脏数据占用的内存没有机会被释放 | 热键的抗压能力需要大于80k，但是少于200k mset/mget：需要较多的跨分片mset/mget支持(目前Redis Sharding和Cluster还没有支持，之后会加入) | 没有高可用方案，节点故障后数据全部丢失，业务需要有回源方案。 |




### 架构选型

**本地缓存**

| 架构类型 | QPS         | 序列化 | GC                       | 内存大小        | 适用场景                                                     |
| -------- | ----------- | ------ | ------------------------ | --------------- | ------------------------------------------------------------ |
| 堆内缓存 | 1000K~7000K | 无     | 受GC影响，且会影响GC频率 | 受JVM堆内存限制 | 需要放在本地缓存中的对象数量少或者内存暂用低且变更频率较低的场景需要QPS超过百万级别 |
| 堆外缓存 | 500k~2000K  | 需要   | 不受GC影响               | 物理内存        | 需要高于共享内存的吞吐量，但是又需要1G以上的的内存或者较多的对象，变更频率相对较高时，不想受GC影响 |



**Redis**

| 架构类型               | 高可用                                | 扩展性                                                       | 哈希算法                       | 适用场景                         | 使用案例                                                     |
| ---------------------- | ------------------------------------- | ------------------------------------------------------------ | ------------------------------ | -------------------------------- | ------------------------------------------------------------ |
| Sharding客户端分片架构 | 主节点宕机后，IP指向从节点            | 扩容后脏数据占据的内存清理由内部线程定期扫描来完成，没有TTL的话则不会清理 | 客户端自定义，一般为一致性哈希 | 业务需要更灵活的控制分片的规则   | 使用redis当分布式锁，获取大于1/2节点的锁才算获取成功每个sharding node都存有全量数据，客户端自己做loadbalance，达到高性能和高可用 |
| Cluster集群架构        | 由内部机制保证，生产30S完成从节点晋升 | 扩容后SLOT槽的数据会被主动迁移，没有脏数据理论上上限是16384，作者建议1024个实例为上限 | CRC16                          | 动态扩容缩容的能力，且数据不丢失 | 大多数情况下我们都该使用Cluster                              |



### 编程规范

| 关键字                  | 注意点                                                       |
| ----------------------- | ------------------------------------------------------------ |
| key                     | key的命名需要包含业务名缩写，使用字母、数字、横线和下划线组成，不要过长，尽量20个字符之内 |
| value                   | String不要超过2K的字节，Memcached中数据大小相差不要太大，Redis中set中数据不要超过5000个 |
| ttl                     | 所有缓存使用的键值都须设置过期时间，缓存过期时间客户端需要设置 过期的Base时间+（0-30秒的随机时间）。防止在缓存预热或批量写缓存的过期时间趋同，导致缓存穿透 |
| key-prefix              | 目前Redis生产上只有db0，所以应当使用key-prefix               |
| SDK版本                 | 不同应用或者域使用相同的缓存的话，最好确保Asgard-cache版本相同，或者Jedis和SpyMemcached版本相同 |
| 连接池                  | 客户端必须有连接池，禁止每次进行建立连接的行为               |
| 获取连接时间            | 一般建议不使用开源框架的默认值，可以使用asgard优化之后的默认配置或者根据自身情况定义获取时间 |
| 超时时间                | 一定要严肃对待超时时间的配置，过长的超时时间，在异常情况下会带来灾难性的危害。请根据本规范中的客户端参数进行相应的修改。建议300-500ms |
| 防穿透                  | 如果qps超过回源通道的最大能力的话，请确保有防穿透功能，以防压垮后端的服务或者存储。目前Asgard-cache对redis，memcached，ares都支持单线程回源的功能。 |
| 冷启动                  | 如果可以的话，请对缓存进行预热，防止冷启动，目前Asgard-cache支持预热功能 |
| 缓存简单对象            | 请确保缓存的都是简单对象，如果需要复杂对象，请使用redis相关的数据结构，防止序列化上的大额开销 |
| 缓存下游数据            | 原则上来说，不建议缓存其他服务的数据，应当由被调用方保证性能，除了某些特殊场景，比如聚合大量下游数据 |
| 后台更新数据            | 后台最好不要去set任何别人需要的缓存，只使用delete，你永远不知道别人get的数据格式变化。跨机房缓存刷新follow这个原则(两个原因，一个是减少数据传输量，一个是数据格式安全) |
| 禁止使用的命令          | Redis: keys *, flushal, flushdbMemcached: flush_all, stats cachedump, stats items |
| 不推荐使用的命令        | redis最好不要使用高复杂度的命令，因为redis是单线程应用，执行慢命令会阻塞其余的所有命令。比如：lrange(0，-1) |
| 热key                   | 尽量将热key分布在不同的示例上，如果热key较多，考虑本地缓存   |
| 关系型数据表转KV        | 统一使用"："作为分隔符，表名:主键值:列值，或者带上一个spacename，比如cache：table：pk：col 这样可读性比较好，key的长度在20字符以内。 |
| Redis建议使用多参数命令 | 使用多参数命令主要的优点是可以减少redis的响应延迟。redis单线程响应所有连接的操作请求，队列中最近的命令需要等待之前所有的命令完成才能开始执行。 使用多参数命令可以减少总体命令量（overall command volume），这样可以减少redis server解析comms的时间，更多的时间可以用来处理数据操作。例如，需要添加1000个元素到一个list中，使用lset需要1000次请求，使用lpush/rpush只需要一次请求。 |



#### 常见方案

| 问题                                   | 解决方案                                                     |
| -------------------------------------- | ------------------------------------------------------------ |
| 使用Redis作为分布式锁                  | 由于Redis是非强一致性的系统，所以如果主宕机，从升为主的情况下，可能会同时出现两个应用实例拿到锁的情况。Redis作者给的方案：参考：<https://github.com/antirez/redis-doc/blob/master/topics/distlock.md>中文翻译：<http://ifeve.com/redis-lock/> |
| 缓存穿透                               | 缓存穿透是指对应的key在后端的存储或者服务上肯定不存在，导致每次查询都会穿透缓存给回源通道带来很大的压力。解决的办法：缓存不存在的KEY，值为空值（业务可以自己定义）对Key进行合法性校验，过滤那些不合法的key |
| 雪崩                                   | 雪崩是指在缓存不可用时，导致了应用线程的阻塞，进而导致了应用的不可用。或者全部穿透到后端的服务上到期后端的服务或者存储也不可用。第一个问题的解决办法是通过合理的设置相关的超时和重试参数，让应用failfast，或者直接使用优化过的asgard cache.第二个问题的解决办法是使用asgard cache的访问治理功能，如单线程回源保护后端的服务。后续asgard将提供更加丰富的治理功能，如故障节点的熔断、限流等 |
| 本地缓存数据一致性                     | 这里的一致性有几层概念：是指本地缓存与后端的存储之间的数据一致性：可以通过VMS的组内广播进行数据同步是指本地缓存间的数据一致性：通过RPC进程间互相通信调用（**实现复杂，且需要处理较多异常问题不建议使用**），一致性要求高的系统建议改用共享缓存。 |
| 实际案例1：邮件去重优化                | 第一批已经发送了200万邮件，第二次还需要发送一批50万邮件，利用redis在这两批收件人中去除相同的收件人。优化之前的操作：直接对两个set进行sdiff优化操作：把邮件按某种照规则（邮件的第一个字符）分到不同的set里面，前后两批次满足同种规则的set进行sdiff比较去重。可以减少大量不必要的比较操作，减少单次操作的数据量，cpu消耗变得平滑。 |
| 实际案例2：应用程序限制redis的写入速度 | 1）storm应用程序需要统计商品的uv信息，当接收到访问日志，并不是立即做HINCRBY 1操作。而是storm中sink一段时间的累加数据，再一次HINCRBY n。这样可以减少reddis的请求数。2）redis限速。每次pipeline之后做一次sleep，保证redis在单位时间内的接收到的请求数在一定的阈值内（10w）。比如16个线程，每个线程执行pipeline里面的命令个数为100个，pipeline执行完成之后sleep 20ms。我们忽略网络io的时间，在饱和状态下，应用程序最大的命令请求数为：16*100*1/0.02 = 8w的cmds。 |



## 配置

这部分将重点介绍生产上缓存使用的情况，配置决定了服务端和客户端的行为。

### 服务端配置

详细的阅读服务端的配置，对于了解服务端的工作原来非常的重要。以下将给出服务端生产上配置列表及重点配置。

#### **Redis**

下面列出参数为用户可能需要了解的参数，因为这些参数会影响客户端的行为

| 配置                          | 参数  | 说明                                                         |
| ----------------------------- | ----- | ------------------------------------------------------------ |
| timeout                       | 300   | 单位是秒，客户端闲置多少秒后断开连接，需要配合客户端的testWhileIdle进行空闲连接检查，**空闲检查的间隔时间需要小于这个值**，否则会出现不断的连接开关的情况影响性能。 |
| tcp-keepalive                 | 600   | 单位是秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞 |
| maxmemory                     | 8gb   | 最大内存                                                     |
| cluster-node-timeout          | 30000 | 单位是毫秒，集群节点超时时间，节点间通过Gossip协议进行通讯，如果目标节点超过这个时间没反应就断定是宕机，然后触发failover。**所以某个节点的最小故障时间是30s, 在此该节点服务的slot将无法提供数据服务。** |
| cluster-slave-validity-factor | 10    | 在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor)+ repl-ping-slave-period如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移 |
| cluster-require-full-coverage | no    | “集群是否需要全量覆盖”，如果设置为yes（默认值），当集群中有slots没有被任何node覆盖（通常是由于某个master失效，但是它也没有slave接管时），集群将会终止接收writes请求；如果设置为no，集群中那些服务正常的nodes（slots）仍然可以继续服 |



### 客户端配置

这里重点介绍了目前公司主要在用的缓存客户端的重点配置项，并提供针对我们这种高并发低延迟的系统优化后的建议值。用户需要仔细阅读相关的配置项以便了解其具体的实现原理，可以根据实际业务的需要来决定是否需要调整相关的配置参数，如对可以用性影响较大的各种超时时间和重试机制，同时当故障或异常发生时也能清楚它背后的原理。



#### **Common-pool**

由于 Jedis, Venus Cache, Asgard Cache 以及众多其他组件都使用了 Common-pool作为连接池的组件，所以本章先将 Common-pool 的配置进行一个完整梳理，并给出建议值。



**推荐配置项**

| 参数                          | 默认值     | 推荐值           | 说明                                                         |
| ----------------------------- | ---------- | ---------------- | ------------------------------------------------------------ |
| maxTotal                      | 8          | N/A              | 对象池中管理的最多对象个数。**应用需要根据实际的访问量自行进行调整。** |
| maxIdle                       | 8          | N/A              | 对象池中最大的空闲对象个数。**应用需要根据实际的访问量自行进行调整。** |
| minIdle                       | 0          | N/A              | 对象池中最小的空闲对象个数。**应用需要根据实际的访问量自行进行调整。** |
| maxWaitMillis                 | -1(不超时) | 300ms            | maxWaitMillis是从连接池中获取连接的最大等待时间，超过该时间会抛出 Could not get a resource from the pool。**应用需要根据自己的服务的最大承受的响应时间进行相应的调整**。**注意**：如果connectionTimeout时间配置的比maxWaitMillis长的话，由于需要先等待连接建立才能返回连接，所以实际的等待时间会超过maxWaitMillis，设置的时候需要相应的调整连接的超时时间，这部分后续会提到。 |
| testOnBorrow                  | false      | false            | 在从对象池获取对象时是否检测对象有效，默认关闭。**开启会产生大量的连接有效性检查的Ping指令对性能影响较大。** |
| testOnReturn                  | false      | false            | 在向对象池中归还对象时是否检测对象有效，默认关闭。**开启会产生大量的连接有效性检查的Ping指令对性能影响较大。** |
| testWhileIdle                 | false      | true             | 需在检测空闲对象线程检测到对象不需要移除时，是否检测对象的有效性。与**timeBetweenEvictionRunsMillis配合使用，用于连接保活。** |
| timeBetweenEvictionRunsMillis | -1         | 90秒             | 空闲对象检测线程的执行周期，即多长时候执行一次空闲对象检测。单位是毫秒数。如果小于等于0，则不执行检测线程。**该值必须小于redis server端的timeout（300s)才能保证连接的有效性。** |
| numTestsPerEvictionRun        | 3          | -1(检测每个对象) | 检测空闲对象线程每次检测的空闲对象的数量。默认值是3；如果这个值小于0,则每次检测的空闲对象数量等于当前空闲对象数量除以这个值的绝对值，并对结果向上取整。 |

**其他配置项**

| 参数                           | 默认值 | 说明                                                         |
| ------------------------------ | ------ | ------------------------------------------------------------ |
| lifo                           | true   | 连接池放池化对象方式，true：放在空闲队列最前面，false：放在空闲队列最后面。好处是在低流量情况下能够省去很多创建和删除的步骤，比如我拿到了一个连接放回队首，下一个线程还从队首拿连接，这样后面不用的连接超过IdleTime就会被销毁了 |
| fairness                       | false  | 类似于Java中的Lock的公平与非公平，true 相当于等待线程是在先进先出去拿空闲连接 |
| blockWhenExhausted             | true   | 当对象池没有空闲对象时，新的获取对象的请求是否阻塞。一般为true，然后配合maxWaitMillis |
| minEvictableIdleTimeMillis     | -1     | 对象最大的空闲时间。如果为小于等于0，最Long的最大值，如果大于0，当空闲的时间大于这个值时，执行移除这个对象操作。 |
| softMinEvictableIdleTimeMillis | 30分钟 | 对象最大的空间时间，如果小于等于0，取Long的最大值，如果大于0，当对象的空闲时间超过这个值，并且当前空闲对象的数量大于最小空闲数量(minIdle)时，执行移除操作。这个和上面的minEvictableIdleTimeMillis的区别是，它会保留最小的空闲对象数量。而上面的不会，是强制性移除的。默认值是-1； |

推荐的配置项建议应用重点进行参考配置，其他配置项有需要的可以进行相应的调整。



#### **Redis**

**序列化**

默认Key采用的是String序列化，Value采用的JDK序列化。

**JDK序列化的开销比较大，强烈建议用户先在外部通过自己的序列化协议换成String后再进行存储，或者作为直接配置一个自定义的序列化实现。也可以直接选择JSON作为序列化的协议。**

**分片规则**

Sharding模式(客户端分片模式)需要用户选择哈希算法，我们建议采用一致性哈希，在Jedis中为Ketama算法。

相比于类似取模的算法，一致性hash的好处是可以在节点数量发生变化时具有更好的**单调性**。



**Jedis 配置**

除了连接池的配置意外，Jedis的以下参数需要重点配置。

| 参数              | Jedis默认值 | 推荐值 | 说明                                                         |
| ----------------- | ----------- | ------ | ------------------------------------------------------------ |
| connectionTimeout | 2s          | 250ms  | connectionTimeout 是connect()方法超时，也就是新建连接时的超时，该超时与新建连接或者说获取连接有关。如果 connectionTimeout 时间到了之后仍然没有连上，则会抛出 connect time out 异常。但是需要注意的是，如果对面机器没有down掉，只是端口没有起来的话(也就是程序down了，机器没有down)，抛出的是 Connection refused 异常！并且该异常返回很迅速，不需要等connectionTimeout 的时间才会抛异常，而如果是机器down掉的话，才会抛出connect time out 异常，希望这一点大家务必能够注意到，因为不同的异常对连接池影响很大，refuse是立即失败，而connect time out则是需要等待connectionTimeout 时间才会失败，这会导致连接池资源耗尽，所以如果对这方面要求高的可以配置短一点，Jedis 默认是两秒。 |
| soTimeout         | 2s          | 250ms  | SoTimeout是读数据超时，会在 SocketInputStream 类中的 read 方法作为参数传递进去，如果读取时间超过了配置的 SoTimeout时间，则会在 native 的 socketRead0 方法中被抛出。Jedis 默认也是两秒。 |
| attempts          | 5           | 3      | **只对redis cluster有效**。该参数 attempts 是 JedisCluster 提供的重试次数，在 JedisCluster 中如果某次访问出现异常，或者建立连接出现异常都会进行重试，具体的完整行为请参看故障章节的故障期间行为，Jedis默认是5次，推荐改为3次。 |



由于超时和重试的机制对应用在缓存节点故障期间的可用性影响较大，如果请求的总的超时时间过长会大量BLOCK应用的线程导致服务不可用，所以清楚的了解应用在极限情况下的最大超时时间非常重要。这里对相关请求的超时时间的计算做重点说明：

- redis cluster: 请求最大响应时间**maxRT=attempts \* (max(connectionTimeout, maxWaitMillis+soTimeout)),** 使用推荐配置则**maxRT=1650ms**
- redis sharding: 请求最大响应时间**maxRT=max(connectionTimeout, maxWaitMillis+soTimeout),** 使用推荐配置则**maxRT=550ms**

**以上均为异常情况下的极限的缓存访问的时间，应用可以根据自己的情况相应的做些调整。**

需要注意的是，目前的Jedis一共有下列几个方法会无视用户设置的SoTimeout并且在执行前将SoTimeout设置为0：

1. blpop
2. brpop
3. brpoplpush
4. eval
5. evalsha
6. proceed
7. psubscribe
8. subscribe

**使用这些命令需要特别注意，线程会被长时间BLOCK。**



## 故障

本节主要关注在服务端出现故障时客户端的一些行为及表现，通过这一部分让用户了解在故障出现时应用可能出现的一些问题以及异常信息，便于快速的定位问题。

### 故障行为

其实服务端出现故障本身不可怕，可怕的应用没有及时的应对错误或者由于不了解实现原理而错误的配置导致应用大量线程被BLOCK而无法提供服务。线程被BLOCK主要是存储访问无法failfast所致，而导致无法failfast的原因是开源框架本身过长的超时时间配置以及过大的重试次数配置，由于故障期间的最大超时时间已经在配置章节介绍过，这里再简单介绍下目前缓存客户端存在的一些重试机制。

客户端在服务端故障(掉电，假死等)期间客户端的行为，虽然不同的故障会导致服务端收到不同的异常，但是对于客户端来说行为是相似的。

|                | 重试                                                         | 故障行为说明                                                 |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Jedis-Sharding | 无                                                           | 使用 ShardedPool 时，多个节点中有一个或多个节点宕机会出现一些问题，先看一下流程：从 Pool 中获取一个 ShardedJedis 对象，向某一个 key 所在的机器发送命令如果执行出现问题，会抛出异常，将这个 key 所在的 Jedis 对象标记成 broken (一个 ShardedJedis 有多个子的 Jedis)执行完毕后会在 finally 方法中调用 ShardedJedis.close() 方法，这个方法里会检测是否broken了，如果有任意一个 Jedis 被标记为 broken，则将整个 ShardedJedis 关闭根据上述流程来看，会出现下述问题：在某一个节点宕机时，如果某次请求访问的是那台节点，则会将整个 ShardedJedis  对象close 掉，即使其他节点的 Jedis 对象都是好的。而此时如果某个请求访问的是别的节点时，则不会关闭，而是放回池中。这样就会导致，由于一个节点的问题，连接池需要不停的新建和关闭 ShardedJedis  对象。并且关闭连接时如果某个Jedis对象还没有建立起连接，会先三次握手建立TCP连接后，再发送QUIT命令，最后在四次挥手关闭连接，非常多此一举。不停的新建和关闭 ShardedJedis  是个非常耗时的工作，需要节点个数次新建 TCP 连接，以及断开，值得注意。 |
| Jedis-Cluster  | attempts 次 (没有抢到更新slotsLock)attempts + 最多 Redis 集群主节点个数次重试 | 尝试从key所对应的节点连接池中获取连接，执行命令获取连接超时，则没有重试，直接异常抛出没有连接池，需要新建连接，但是出现错误(如 connectionTimeout)，则进入第二步执行命令出错，比如connect refuse，也进入第二步Jedis 认为可能是某个节点出了问题(比如主节点down了)，此时会进行重试如果没有重试次数了，则进行更新节点信息递归执行第一步捕获 JedisRedirectionException，更新slots或者发送命令给指定节点如果是MOVED指令，则更新slots，递归执行第一步ASK指令则进入第一步，并递归执行第一步且通过ASK返回的目标节点发送命令每一次递归调用时，attempts会减一 |



# 数据库

## 配置

### 服务端配置

了解mysql的一些重要配置项可以更好的指导客户端的配置以及清楚的知道在各种情况下的一些可能的异常行为。主要参数如下：

| 参数名                   | 值     | 备注                                                         |
| ------------------------ | ------ | ------------------------------------------------------------ |
| max_connections          | 3000   | 该实例的最大连接数                                           |
| wait_timeout             | 120s   | 非交互式连接的最大空闲连接，JDBC访问的属于此类。超过指定的时间没有语句指令交互则服务端关闭连接。**应用端的连接池配置的保活时间必须小于这个值，否则连接会被关闭。** |
| interactive_timeout      | 120s   | 交互式连接的最大空闲连接，mysql client访问的属于此类。超过指定的时间没有语句指令交互则服务端关闭连接。 |
| connect_timeout          | 10s    | 等待handshake完成的最大时间，否则等待bad handshake           |
| net_read_timeout         | 3s     | 在终止读之前，从一个连接获得数据而等待的时间秒数；当服务正在从客户端读取数据时，net_read_timeout控制何时超时。 |
| net_write_timeout        | 6s     | 在终止写之前，等待多少秒把block写到连接；当服务正在写数据到客户端时，net_write_timeout控制何时超时 |
| slave-net-timeout        | 30     | 当slave认为连接master的连接有问题时，就等待N秒，然后断开连接，重新连接master |
| long_query_time          | 0.300s | 当一个操作的时间大于这个值是被认为是慢SQL                    |
| innodb_lock_wait_timeout | 30s    | Innodb的最大表行锁等待的时间，超过该时间客户端会出现锁等待超时。**如果发现出现大量的超时，请联系DBA关闭BLOCKER的session**。 |

### 客户端配置

 本节将介绍应用用的较多的几种连接池的推荐配置，以及Driver的推荐配置。一个错误的配置将导致非常严重的性能或者可用性问题，如过大的获取连接超时时间将有可能导致应用被挂起，或者开启了获取连接时的连接有效性检查会导致数据库的压力增加影响性能。

#### 连接池

连接池配置的几个原则：

- 连接有效性检查的方式：如果打开**获取或者归还连接的有效性检查的选项**会产生大量的有效性检查的指令对数据库产生很大的压力，而且随着QPS的增加而同步增加。连接的保活机制最好不要对数据库产生额外的过高的负担，不应该随着QPS的变化而变化。所以**建议关闭这两个选项**。
- 有效性检查的间隔时间：连接有效性检查间隔时间**必须要要小于**数据库的连接超时关闭的时间，否则连接会被数据库提前关闭而导致应用拿到一个无效的连接。
- 有效性检查的指令：目前大部分数据库连接池均已经实现了**JDBC4的规范**，支持通过**Connection.isValid**来判断连接的有效性，且均为默认实现。而mysql driver针对该方法的实现是通过**Mysql的轻量级的ping指令**，具有更好的性能。**所以建议不再配置validateQuery，直接使用默认的即可**。
- 连接数的配置：由于**连接数的大小取决于特定业务的访问量和事务的大小**，所以无法给出推荐值，建议通过压测进行评估后进行调整。



##### Druid

Druid的连接池是基于Common-pool实现的，所以配置上比较简单，请参考上面的



连接池配置

##### C3P0

| 参数                         | 默认值        | 推荐值                        | 说明                                                         |
| ---------------------------- | ------------- | ----------------------------- | ------------------------------------------------------------ |
| **initialPoolSize**          | 3             | NA                            | 首次获取连接时需要创建的连接数量（**并非是数据源初始化时创建）**。**应用需要根据实际的访问量自行进行调整。** |
| **minPoolSize**              | 3             | 建议与initialPoolSize保持一致 | 池中保留的最小连接数。**应用需要根据实际的访问量自行进行调整。** |
| **maxPoolSize**              | 15            | N/A                           | 允许创建的最大连接数。**应用需要根据实际的访问量自行进行调整。** |
| **idleConnectionTestPeriod** | 0 （不检查）  | 90                            | 心跳检测时间(单位 s)，默认为不开启。**推荐值为90秒小于数据库的连接空闲关闭的最大时间120s** |
| **maxIdleTime**              | 0 （不过期）  | 1800                          | 最大空闲时间(单位 s)，超过该事件后被关闭.                    |
| **checkoutTimeout**          | 0 (永远等待） | 300ms                         | 获取连接等待超时时间(单位ms)。                               |
| testConnectionOnCheckout     | false         | false                         | 获取连接检测                                                 |
| testConnectionOnCheckin      | false         | false                         | 归还连接检测                                                 |
| `numHelperThreads`           | 3             | 3                             | 对数据库比较重的操作均通过该线程池完成，如连接建立和归还，所以它的大小取决于业务的QPS |
| preferredTestQuery           | 空            | 空                            | 默认是如果driver支持jdbc4则先使用jdbc4.isValid（效率高），否则是调用getTables(比较慢） |

粗体的参数用户需要重点关注，红色的部分用户必须要根据应用的情况进行调整。



#### Driver

| 名称                | 默认值   | 推荐值 | 含义                                                         |
| ------------------- | -------- | ------ | ------------------------------------------------------------ |
| **connectTimeout**  | 0(毫秒） | 250    | 连接超时时间，默认为永不超时。（**当使用异步连接池时，该参数不会BLOCK用户线程。**） |
| enableQueryTimeouts | true     | true   | 默认为支持Statement.setQueryTimeout，开启后会占用额外的内存(Timer)，高性能场景建议关闭。**但是对可用性要求高的应用建议打开并结合Statement.setQueryTimeout使用。** |
| **socketTimeout**   | 0(毫秒） | N/A    | 全局的网络操作超时时间，默认为永不超时，实际上通过SO_TIMEOUT来实现的。**可用性要求高的系统可以设置一个合理的值，比如小于服务调用超时时间的值。或者可以针对某些可能执行时间较长的语句通过设置Statement.setQueryTimeout来设置语句级别的超时时间。否则一旦由于网络或者服务端的问题会导致业务线程挂起。** |
| **useAffectedRows** | false    | N/A    | 默认情况下当根据某个条件update某一个column时，返回值是查找到的记录数。**如果用户希望拿到的是由于column值新旧不同而被实际变更的记录数而不是查找到的记录数则需要开启该选项。** |



#### 最大响应时间

响应时间对应用的可用性极大，所以了解如何根据连接池的配置来计算每个请求的最大响应时间非常重要。由于以上三种连接池都是异步建立连接的，所以客户端一次数据库访问的最大响应时间为：

maxRT = 获取连接的超时时间 + max(socketTimeout, queryTimeout)，还受服务端的连接空闲时间影响等。



## 使用

这里主要介绍主要的DDL/DML使用时的一些注意事项

### DDL

- 使用自增ID作为主键：可以提高写入、查询效率的同时也能降低内存和存储的占用

- 所有表必须有create_time和last_update_time，方便后期数据分析与记录变化排查

    ```sql
   `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', 
     `update_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '数据变更时间',
    ```

- 所有表记录建议进行逻辑删除而不是物理删除

- 字符型字段的size越小查询性能越好



### DML

- 尽量用单表查询，避免多表JOIN，禁止多于3表join，join的字段数据类型必须绝对一致
- 禁止使用 UUID()，USER()这样的MYSQL INSIDE函数对于复制来说是很危险的，会导致主备数据不一致，重要的是会严重影响mysql性能。
- 禁止default NULL，数字类型not null default 0，字符类型not null default ''，时间not null default '1970-01-01 00:00:00'或者 ‘0000-00-00 00:00:00’。除了NULL会占用更多的存储之外，对NULL的字段的count和count（*）的结果不一致，前者不包含NULL的字段的ROW而后者包含。
- 如果是直接使用jdbc的请一定要使用PrepareStatement避免SQL注入的安全隐患，如果使用的是Mybaits，则请不要使用${var}的变量形式，而是使用#{var}的变量，前者是直接变量替换后者会使用PrepareStatment.



**操作超时设置**

由于默认的超时时间都是0即不超时，那么对那些可用性要求较高的应用来说可能会因为一些故障原因线程被挂起，所以合理的根据应用的场景设置数据库的操作时间非常重要。

有两种设置方式：

- 全局级别设置 - 通过driver的socketTimeout参数设置，请参考Driver部分。
- 语句级别设置 - 通过Statement.setQueryTimeout来设置，但是该参数的单位是秒，所以无法实现毫秒级别的超时设置，且Driver会针对每个查询设置一个Timer来实现，一定程度上会影响性能。

应用需要根据实际语句的情况来设置setQueryTimeout，比如不希望某些语句执行时间过长则可以通过该方法来指定一个超时时间。一旦触发超时，Driver发通知mysql去kill掉这个语句，连接不受影响。

有两种方式可以类配置queryTimeout:

通过Mybatis的全局配置文件，配置所有语句的超时时间 

```xml
<setting name="defaultStatementTimeout" value="25"/>
```



通过Mybatis的映射文件指定某个语句的超时时间 

```
<insert  id="insertAuthor"  parameterType="domain.blog.Author"  timeout="20">
```



### 事务

要知道如何来使用事务，必须先了解事务的两个属性：

1. 事务隔离级别 - **目前生产上mysql配置的事务隔离级别是提交读而不是默认的可重复读**

    提交读(READ COMMITTED)级别中保证了读到的任何数据都是提交的数据 

2. 事务传递级别 

错误的使用事务的传递级别可能会对应用带来非常重要的影响，所以仔细的了解各个事务的传递级别的含义及适用范围有助于提高应用的质量。



事务使用的最佳实践： 

+ 短事务 
  - 减少连接占用的时间有助于提高连接的利用率，同时有助于提高吞吐能力
  - 减少数据库锁的持有时间，有助于提高吞吐能力。比如一个事务先更新了一跳记录，但是迟迟不提交，其他需要获取该记录的行锁的线程就会被一直BLOCK。（目前锁超时时间是30s)

-  单语句的方法不要添加事务 
  - 单语句本身就是原子事务，如果也添加了事务的话，会额外的多出多次set autocommit=xxx的指令，影响性能。



### 拆库

**读写分离**

读写分离的架构易于扩展度能力的同时也带来了数据一致性的问题，生产上有不少因为从库delay导致的异常或者故障的案例。所以原则上：

- 已经水平拆库的系统不再建议使用读写分离
- 一个事务内读请求或者对一致性要求高的读请求必须走写库

**水平拆分**

当读写分离已经无法满足需求时，需要考虑进行水平拆分，主要有以下几个参考原则：

- 读写量都很大：比如1主多从的情况下，主库还需要6K+的TPS的需求的情况
- 主库的存储容量需求大：当超过2T的需求的情况下，需要考虑水平拆分
- 一致性要求高：由于读写分离后，主库和从库可能存在的数据同步延迟，所以对一致性要求高的场景需要考虑水平拆分

### **多数据源**

随着架构的演变，应用访问的数据库进行了垂直拆分，但是依然有不少应用存在着一个应用同时访问多个数据源即多个垂直库（这里的库是逻辑概念，内部还可以进行水平拆分）的情况，这种使用方式存在如下的一些弊端：

- 如果该库的数据模型是别的团队维护的，那么当数据模型发生变化时，直接访问该库的应用可能会收到影响，增加了额外的沟通的成本。
- 无法对数据访问进行统一的控制，比如安全、权限、流量等控制
- 每个应用都有相同的一套底层的数据模型存在，该数据模型架构演进和升级的成本大大增加

所以，原则上我们尽量禁止一个应用同时访问多个数据源的情况：

- 统一使用服务化的接口进行调用，使得同一套数据模型只有一套高内聚的数据访问入口
- 因为某些特殊原因必须要访问多数据源时，也请遵守以下原则：
  1. 垂直拆分的库需要配置独立的数据源，避免将垂直拆分的库配置到一个数据源当中，然后通过分库策略进行路由的使用方式。**实践证明该配置方式较容易出错，尤其当有事务需要时，事务内部的方法又需要指定独立的事务传递级别，对data原理和事务原理不是非常熟悉的情况下非常容易出现问题。**
  2. 配置文件和代码上请严格分离，不同数据源的代码和配置尽量使用独立的包和目录结构。**好处是将来对两个库进行服务化拆分时比较简单，直接把某个库的代码和配置剥离到新的工程中即可。**





## 常见异常



### **Jedis**

| Exception                                                    | 说明                                                         | 典型Root Cause异常信息                                       | 出现概率                                                     | ErrorCode                                                    | 可能出现的原因及排查与解决办法                               |                                                              |                                                              |                                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| JedisException                                               | 继承自Runtime异常，所有Jedis异常的父类，Jedis的重试机制不捕获本异常，所以一旦出现，则本次操作直接失败。一般由连接池相关操作(并不是全部操作，而是作者认为不该重试，比如获取连接超时，但是某种情况上来说，connectionTimeout也应当不进行重试)，需要重点关注encode方法，牵扯到了所有的命令，但是此原因导致JedisException的可能性很小 | Could not get a resource from the pool：Timeout waiting for idle object | HIGH                                                         | 1-001                                                        | 池中资源不够用。此时需要更多的连接数，需要调大maxTotal即可服务端有慢查询，阻塞了客户端操作，可以查看服务端监控来排查，可以查询 Read timed out 关键字网络抖动或者延迟，导致了执行时间过长，但是有没有超时，从而影响了后续线程获取连接，此时可以查看Mercury上的一次请求的响应时间 |                                                              |                                                              |                                                          |
| Could not get a resource from the pool：Unable to validate object | MIDDLE                                                       | 1-002                                                        | 在创建连接时，同时开启了 testOnCreate，但是检测失败。可能是网络问题或者服务端慢查询阻塞了客户端的PING请求 |                                                              |                                                              |                                                              |                                                              |                                                          |
| Could not return the resource to the pool： Connection refused: connect | MIDDLE                                                       | 1-003                                                        | 由于Commons-pool在归还连接后会进行ensureIdle操作，但此时Redis服务不可用，则会导致create失败，抛出该异常 |                                                              |                                                              |                                                              |                                                              |                                                          |
| Could not return the resource to the pool： Connect timed out | MIDDLE                                                       | 1-004                                                        | 由于Commons-pool在归还连接后会进行ensureIdle操作，但此时网络不通，或者Redis所在机器宕机，则会导致create失败，抛出该异常 |                                                              |                                                              |                                                              |                                                              |                                                          |
| Unknown message type                                         | LOW                                                          | 1-005                                                        | subscribe命令才会出现的异常，格式不符合，可能是多线程导致的  |                                                              |                                                              |                                                              |                                                              |                                                          |
|                                                              | JedisConnectionException                                     | 和Connection相关的操作可能触发的异常，包括新建连接和读写操作等，都是连接层面的问题，大多数是网络问题或者是服务端处理数据时发生了错误，平时遇到的异常基本都属于这一类 | IOException                                                  | MIDDLE                                                       | 1-006                                                        | Cluster模式和单节点模式下是创建时即connect，如果connect出现异常，会被Commons-pool封装，所以只有Sharding模式才会抛出此异常，并且是应当在创立之后的第一次请求发生异常。排查网络相关的问题即可。 |                                                              |                                                          |
| Could not get a resource from the pool： Connection Refuse   | HIGH                                                         | 1-007                                                        | 连接不够新建连接失败，会抛出此异常，原因是Redis资源进程宕机，或者listen参数的backlog已满 |                                                              |                                                              |                                                              |                                                              |                                                          |
| Could not get a resource from the pool： Connect timed out   | HIGH                                                         | 1-008                                                        | 连接不够新建连接失败，会抛出此异常，原因是Redis服务所在机器宕机，或者网络不通 |                                                              |                                                              |                                                              |                                                              |                                                          |
| Unexpected end of stream                                     | HIGH                                                         | 1-009                                                        | 本质原因是与Redis服务连接断开，客户端发起请求后，对方回了FIN包，客户端收到后poll方法直接返回，Jedis读取不到数据，则返回该异常。此异常排查为何连接断开，是否长时间没有使用连接，导致被Redis服务器主动断开。 |                                                              |                                                              |                                                              |                                                              |                                                          |
| JedisPubSub is not subscribed to a Jedis instance.           | LOW                                                          | 1-010                                                        | JedisPubSub没有关联到具体的Redis服务                         |                                                              |                                                              |                                                              |                                                              |                                                          |
| Unknown reply                                                | MIDDLE                                                       | 1-011                                                        | 服务端返回的响应的第一个字符，不合符Redis协议，可能会发生在多线程场景下，数据错乱，或者某个连接在发生broken了之后，没有close，继续读取下一个请求 |                                                              |                                                              |                                                              |                                                              |                                                          |
| It seems like server has closed the connection               | MIDDLE                                                       | 1-012                                                        | 和上面Unexpected end of stream异常原因相似，但是抛出的方法不同，可以和上述异常相同的方式排出，查看是否是太长时间不用连接关闭。 |                                                              |                                                              |                                                              |                                                              |                                                          |
| Unexpected character!                                        | LOW                                                          | 1-013                                                        | 读取到了非期望中的数据，基本上这一类都是数据错乱的原因导致   |                                                              |                                                              |                                                              |                                                              |                                                          |
| Read time out                                                | HIGH                                                         | 1-014                                                        | 读数据超时，一般来说是网络问题，或者Redis端有慢操作阻塞，可以查看网络监控，和Redis的监控，同时如果该异常频繁发生，确保你的soTimeout值配置的是否太小 |                                                              |                                                              |                                                              |                                                              |                                                          |
|                                                              |                                                              | JedisNoReachableClusterNodeException                         | 只会出现在Cluster模式下随机获取连接时，没有一个Jedis实例能访问才会抛出此异常 | No reachable node in cluster                                 | LOW                                                          | 1-015                                                        | 集群全部不可用，可能性很低                                   |                                                          |
|                                                              | JedisDataException                                           | 如果客户端在发送命令时处于了MULTI和PIPELINE模式并在等待响应，或者收到的响应中有未识别的 errorMsg | Cannot use Jedis when in Multi. Please use Transation or reset jedis state | LOW                                                          | 1-090                                                        | 发生可能性不高，查看使用方式是否有问题，比如在Multi时继续使用了Jedis |                                                              |                                                          |
|                                                              |                                                              | JedisBusyException                                           | 服务端正在执行脚本                                           | BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE. | LOW                                                          | 1-091                                                        | 查看是否运行脚本                                             |                                                          |
|                                                              |                                                              | JedisClusterException                                        | Cluster模式下特有的异常，                                    | No way to dispatch this command to Redis Cluster.            | LOW                                                          | 1-016                                                        | 发送命令不合法                                               |                                                          |
|                                                              |                                                              | CLUSTERDOWN                                                  | LOW                                                          | 1-092                                                        | 集群不可用，注意Redis有个配置cluster-require-full-coverage，如果该配置为yes时，只要一个slot不可用，就会发送CLUSTERDOWN，请确保配置为no |                                                              |                                                              |                                                          |
|                                                              |                                                              |                                                              | JedisClusterCrossSlotException                               |                                                              |                                                              |                                                              | 1-093                                                        |                                                          |
|                                                              |                                                              | JedisClusterMaxRedirectionsException                         | Cluster模式下重试次数过多，Cluster模式下需要配置maxAttempts参数，默认是5次，在大多数情况下需要重试maxAttempts次之后才会失败| Too many Cluster redirections?                               | HIGH                                                         | 1-017                                                        | 排查前先确定Jedis版本 ，2.8.1和2.8.2之间这一块有些差别Redis服务发生SLOT迁移，可能会导致该异常网络问题，Read timeout 或者 Connection timeout，导致每次都失败，排查网络状况(只有2.8.2之前版本才会)Redis 服务某个主出现了进行宕掉，此时会有30s的时间内访问该服务上的key没有响应(只有2.8.2之前版本才会) |                                                          |
|                                                              |                                                              | JedisNoScriptException                                       | 执行脚本时出现的异常                                         | NOSCRIPT No matching script. Please use EVAL.                | LOW                                                          | 1-094                                                        | 检查脚本是否存在                                             |                                                          |
|                                                              |                                                              | JedisRedirectionException                                    |                                                              |                                                              |                                                              |                                                              |                                                              |                                                          |
|                                                              |                                                              |                                                              | JedisAskDataException                                        | Redis正在执行SLOT迁移时发生的异常                            | ASK                                                          | MIDDLE                                                       | 1-095                                                        | 检查是否正在发生SLOT迁移                                 |
|                                                              |                                                              |                                                              | JedisMovedDataException                                      | 客户端与服务端SLOTS信息不匹配导致                            | MOVED                                                        | MIDDLE                                                       | 1-096                                                        | 访问的key不在本Redis服务上，需要重新renew客户端slots信息 |

由于默认的超时时间都是0即不超时，那么对那些可用性要求较高的应用来说可能会因为一些故障原因线程被挂起，所以合理的根据应用的场景设置数据库的操作时间非常重要。

有两种设置方式：

- 全局级别设置 - 通过driver的socketTimeout参数设置，请参考Driver部分。
- 语句级别设置 - 通过Statement.setQueryTimeout来设置，但是该参数的单位是秒，所以无法实现毫秒级别的超时设置，且Driver会针对每个查询设置一个Timer来实现，一定程度上会影响性能。

应用需要根据实际语句的情况来设置setQueryTimeout，比如不希望某些语句执行时间过长则可以通过该方法来指定一个超时时间。一旦触发超时，Driver发通知mysql去kill掉这个语句，连接不受影响。

有两种方式可以类配置queryTimeout:

1. 通过Mybatis的全局配置文件，配置所有语句的超时时间

   **settings.xml**

2. 通过Mybatis的映射文件指定某个语句的超时时间

   **mappings.xml**


### 事务

由于默认的超时时间都是0即不超时，那么对那些可用性要求较高的应用来说可能会因为一些故障原因线程被挂起，所以合理的根据应用的场景设置数据库的操作时间非常重要。

有两种设置方式：

- 全局级别设置 - 通过driver的socketTimeout参数设置，请参考Driver部分。
- 语句级别设置 - 通过Statement.setQueryTimeout来设置，但是该参数的单位是秒，所以无法实现毫秒级别的超时设置，且Driver会针对每个查询设置一个Timer来实现，一定程度上会影响性能。

应用需要根据实际语句的情况来设置setQueryTimeout，比如不希望某些语句执行时间过长则可以通过该方法来指定一个超时时间。一旦触发超时，Driver发通知mysql去kill掉这个语句，连接不受影响。

有两种方式可以类配置queryTimeout:

1. 通过Mybatis的全局配置文件，配置所有语句的超时时间

   **settings.xml**

2. 通过Mybatis的映射文件指定某个语句的超时时间

   **mappings.xml**


