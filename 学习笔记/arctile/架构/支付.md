#### 代扣可靠性
+ 避免重复扣款
+ 防止代扣未处理
+ 确保用户银行卡扣款和销账的事务一致性

#### 幂等
幂等性是系统的接口一种承诺，承诺只要调用接口成功，多次相同的输入会有相同的结果反馈  

>唯一性控制 
+ 约定唯一性字算，作为是否重复提交的判断依据
+ 通常设计一张幂等表，唯一性做幂等性控制


#### 限流算法定义
+ 漏桶算法
+ 令牌桶算法
+ 计数器算法


>`漏桶(LeakyBucket)算法`思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),
当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率

>`令牌桶算法`当网络设备衡量流量是否超过额定带宽时，需要查看令牌桶，而令牌桶中会放置一定数量的令牌，
一个令牌允许接口发送或接收1bit数据（有时是1Byte数据），当接口通过1bit数据后，同时也要从桶中移除一个令牌。
当桶里没有令牌的时候，任何流量都被视为超过额定带宽,只有当桶中有令牌时，数据才可以通过接口。令牌桶中的令牌不仅仅可以被移除，同样也可以往里添加，
所以为了保证接口随时有数据通过，就必须不停地往桶里加令牌，由此可见，往桶里加令牌的速度，就决定了数据通过接口的速度。
因此，我们通过控制往令牌桶里加令牌的速度从而控制用户流量的带宽。而设置的这个用户传输数据的速率被称为承诺信息速率

>`计数器`计算最近一秒钟窗口内的计数桶请求总数量，作为当前QPS速率,如果QPS大于阈值，则限流.否则按时间落入计数桶

可以使用Guava的RateLimiter来实现。其中SmoothBurstry是基于令牌桶算法的，SmoothWarmingUp是基于漏桶算法的。

#### 限流算法特点
>漏桶
+ 固定容量的桶
+ 水流出速率恒定
+ 如果桶是空的，则不需流出
+ 如果桶满了，则限流

实现方式
+ 队列方式
    + FIFO缓冲队列
    + 平滑流量
+ 计数器方式
    + 计算水滴的数量，判断桶是否满
    + 随着时间消逝，水滴自动减少
    + 允许突发流量
    + 实质是令牌桶算法的镜像算法


>令牌桶
+ 固定容量的令牌桶
+ 令牌生成速率恒定
+ 请求达到移除令牌数(可以一次多个请求)
+ 如果令牌不够则限流
+ 允许突发流量
    + 移除令牌做速率控制
    + 实现线性突发（平滑)  

![token](https://github.com/tinysKai/JavaNote/blob/master/image/article/2018/0709/tokenbucket.png)
    

>计数器  
+ 按精度要求设置计数桶
+ 请求达到的处理
    + 计算最近一秒钟窗口内的计数桶请求总数量，作为当前QPS速率
    + 如果QPS大于阈值，则限流
    + 否则按时间落入计数桶
+ 优点
    + 简单易懂
    + 代码实现简单
    + 自带QPS统计
+ 缺点
    + 精度越高，资源消耗越多
    + 精度越低，毛刺越严重，最坏情况下，实际流量翻倍
       
![token](https://github.com/tinysKai/JavaNote/blob/master/image/article/2018/0709/counter.png)
   