# 秒杀系统笔记

#### 定义

秒杀就是在同一个时刻有大量的请求争抢购买同一个商品并完成交易



#### 痛点 

+ 并发读
+ 并发写



#### 架构原则

- 用户请求的数据尽量少
- 请求数尽量少
- 路径尽量短
- 依赖尽量少
- 不要有单点



#### 二八规则处理热点数据

**“热点”分类**

+ 热点操作
+ 热点数据



**热点数据分类**

+ 静态热点数据  -- 后台运营系统,大数据隔天计算 
+ 动态热点数据  -- 动态热点发现系统



**处理热点数据常见思路**

+ 优化	-- 缓存
+ 限制        -- 限制更多的是一种保护机制,避免单个热点商品拖垮整个系统
+ 隔离
  + 业务隔离    -- 比如秒杀活动单独抽出来
  + 系统隔离    
  + 数据隔离



#### 流量削峰

**削峰基本思路**

+ 排队			--  消息队列
+ 答题,验证码
+ 分层过滤



**分层校验的基本原则**

+ 将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读
+ 对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题
+ 对写数据进行基于时间的合理分片，过滤掉过期的失效请求
+ 对写请求做限流保护，将超出系统承载能力的请求过滤掉
+ 对写数据进行强一致性校验，只保留最后有效的数据



**削峰总结**

队列缓冲方式更加通用，它适用于内部上下游系统之间调用请求不平缓的场景，由于内部系统的服务质量要求不能随意丢弃请求，所以使用消息队列能起到很好的削峰和缓冲作用。

答题更适用于秒杀或者营销活动等应用场景，在请求发起端就控制发起请求的速度，因为越到后面无效请求也会越多，所以配合后面介绍的分层拦截的方式，可以更进一步减少无效请求对系统资源的消耗。

分层过滤非常适合交易性的写请求，比如减库存或者拼车这种场景，在读的时候需要知道还有没有库存或者是否还有剩余空座位。但是由于库存和座位又是不停变化的，所以读的数据是否一定要非常准确呢？其实不一定，你可以放一些请求过去，然后在真正减的时候再做强一致性保证，这样既过滤一些请求又解决了强一致性读的瓶颈。



#### 性能

系统服务端性能，一般用 QPS（Query Per Second，每秒请求数）来衡量，还有一个影响和 QPS 也息息相关，那就是响应时间（Response Time，RT），它可以理解为服务器处理响应的耗时。

**如何优化系统**

+ 减少编码  --减少字符与字节的转换
+ 减少序列化
+ Java 极致优化
  + 直接使用servlet处理请求
  + 直接使用输出流返回数据
+ 并发读优化



**减库存**

**减库存几种方式**

+ 下单减库存  -- 适合秒杀场景
+ 付款减库存  -- 会出现下单付不了款的情况
+ 预扣库存      -- 适合购物网站



下单减库存”在数据一致性上，主要就是保证大并发请求时库存数据不能为负数

一般我们有多种解决方案：

+ 在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚

+ 直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错

+ 使用 CASE WHEN 判断语句，例如这样的 SQL 语句：

  ```sql
  UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END
  ```



#### 兜底

**保障措施**

+ 降级
+ 限流
+ 拒绝

















